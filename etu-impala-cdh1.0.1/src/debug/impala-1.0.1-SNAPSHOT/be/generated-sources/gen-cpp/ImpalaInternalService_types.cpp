/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ImpalaInternalService_types.h"

#include <algorithm>

namespace impala {

int _kImpalaInternalServiceVersionValues[] = {
  ImpalaInternalServiceVersion::V1
};
const char* _kImpalaInternalServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _ImpalaInternalServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kImpalaInternalServiceVersionValues, _kImpalaInternalServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TQueryOptions::ascii_fingerprint = "7ED06B6A6ADFDB99E5CE3EDEF45B4ABC";
const uint8_t TQueryOptions::binary_fingerprint[16] = {0x7E,0xD0,0x6B,0x6A,0x6A,0xDF,0xDB,0x99,0xE5,0xCE,0x3E,0xDE,0xF4,0x5B,0x4A,0xBC};

uint32_t TQueryOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_error);
          this->__isset.abort_on_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_errors);
          this->__isset.max_errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disable_codegen);
          this->__isset.disable_codegen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batch_size);
          this->__isset.batch_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_nodes);
          this->__isset.num_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_scan_range_length);
          this->__isset.max_scan_range_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_scanner_threads);
          this->__isset.num_scanner_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_io_buffers);
          this->__isset.max_io_buffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allow_unsupported_formats);
          this->__isset.allow_unsupported_formats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->default_order_by_limit);
          this->__isset.default_order_by_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug_action);
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_limit);
          this->__isset.mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abort_on_default_limit_exceeded);
          this->__isset.abort_on_default_limit_exceeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TQueryOptions");

  if (this->__isset.abort_on_error) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("abort_on_error", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->abort_on_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_errors) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("max_errors", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->max_errors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disable_codegen) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("disable_codegen", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->disable_codegen);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batch_size) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("batch_size", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->batch_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nodes) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_nodes", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->num_nodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_scan_range_length) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("max_scan_range_length", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->max_scan_range_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_scanner_threads) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_scanner_threads", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->num_scanner_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_io_buffers) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("max_io_buffers", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->max_io_buffers);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.allow_unsupported_formats) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("allow_unsupported_formats", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->allow_unsupported_formats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_order_by_limit) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("default_order_by_limit", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->default_order_by_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mem_limit) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("mem_limit", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->mem_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.abort_on_default_limit_exceeded) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("abort_on_default_limit_exceeded", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->abort_on_default_limit_exceeded);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryOptions &a, TQueryOptions &b) {
  using ::std::swap;
  swap(a.abort_on_error, b.abort_on_error);
  swap(a.max_errors, b.max_errors);
  swap(a.disable_codegen, b.disable_codegen);
  swap(a.batch_size, b.batch_size);
  swap(a.num_nodes, b.num_nodes);
  swap(a.max_scan_range_length, b.max_scan_range_length);
  swap(a.num_scanner_threads, b.num_scanner_threads);
  swap(a.max_io_buffers, b.max_io_buffers);
  swap(a.allow_unsupported_formats, b.allow_unsupported_formats);
  swap(a.default_order_by_limit, b.default_order_by_limit);
  swap(a.debug_action, b.debug_action);
  swap(a.mem_limit, b.mem_limit);
  swap(a.abort_on_default_limit_exceeded, b.abort_on_default_limit_exceeded);
  swap(a.__isset, b.__isset);
}

const char* TScanRangeParams::ascii_fingerprint = "49EB5061C355C63039A2B1360DCA31EE";
const uint8_t TScanRangeParams::binary_fingerprint[16] = {0x49,0xEB,0x50,0x61,0xC3,0x55,0xC6,0x30,0x39,0xA2,0xB1,0x36,0x0D,0xCA,0x31,0xEE};

uint32_t TScanRangeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scan_range = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scan_range.read(iprot);
          isset_scan_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->volume_id);
          this->__isset.volume_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scan_range)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TScanRangeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TScanRangeParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("scan_range", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scan_range.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.volume_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("volume_id", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->volume_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRangeParams &a, TScanRangeParams &b) {
  using ::std::swap;
  swap(a.scan_range, b.scan_range);
  swap(a.volume_id, b.volume_id);
  swap(a.__isset, b.__isset);
}

const char* TPlanFragmentDestination::ascii_fingerprint = "2051EF3AC86CAA635A348C806F3F3AE0";
const uint8_t TPlanFragmentDestination::binary_fingerprint[16] = {0x20,0x51,0xEF,0x3A,0xC8,0x6C,0xAA,0x63,0x5A,0x34,0x8C,0x80,0x6F,0x3F,0x3A,0xE0};

uint32_t TPlanFragmentDestination::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragment_instance_id = false;
  bool isset_server = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->server.read(iprot);
          isset_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_server)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentDestination::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPlanFragmentDestination");

  ++fcnt;
  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b) {
  using ::std::swap;
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.server, b.server);
}

const char* TPlanFragmentExecParams::ascii_fingerprint = "BB37ED8AA279F326A9A871018AAAB452";
const uint8_t TPlanFragmentExecParams::binary_fingerprint[16] = {0xBB,0x37,0xED,0x8A,0xA2,0x79,0xF3,0x26,0xA9,0xA8,0x71,0x01,0x8A,0xAA,0xB4,0x52};

uint32_t TPlanFragmentExecParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_query_id = false;
  bool isset_fragment_instance_id = false;
  bool isset_per_node_scan_ranges = false;
  bool isset_per_exch_num_senders = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_id.read(iprot);
          isset_query_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_node_scan_ranges.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
               ::impala::TPlanNodeId _key5;
              xfer += iprot->readI32(_key5);
              std::vector<TScanRangeParams> & _val6 = this->per_node_scan_ranges[_key5];
              {
                _val6.clear();
                uint32_t _size7;
                ::apache::thrift::protocol::TType _etype10;
                xfer += iprot->readListBegin(_etype10, _size7);
                _val6.resize(_size7);
                uint32_t _i11;
                for (_i11 = 0; _i11 < _size7; ++_i11)
                {
                  xfer += _val6[_i11].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_node_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_exch_num_senders.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
               ::impala::TPlanNodeId _key17;
              xfer += iprot->readI32(_key17);
              int32_t& _val18 = this->per_exch_num_senders[_key17];
              xfer += iprot->readI32(_val18);
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_exch_num_senders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->destinations.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->destinations.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->destinations[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.destinations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->debug_node_id);
          this->__isset.debug_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->debug_phase = ( ::impala::TExecNodePhase::type)ecast24;
          this->__isset.debug_phase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->debug_action = ( ::impala::TDebugAction::type)ecast25;
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_query_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_node_scan_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_exch_num_senders)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanFragmentExecParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPlanFragmentExecParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("query_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->query_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("per_node_scan_ranges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->per_node_scan_ranges.size()));
    std::map< ::impala::TPlanNodeId, std::vector<TScanRangeParams> > ::const_iterator _iter26;
    for (_iter26 = this->per_node_scan_ranges.begin(); _iter26 != this->per_node_scan_ranges.end(); ++_iter26)
    {
      xfer += oprot->writeI32(_iter26->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter26->second.size()));
        std::vector<TScanRangeParams> ::const_iterator _iter27;
        for (_iter27 = _iter26->second.begin(); _iter27 != _iter26->second.end(); ++_iter27)
        {
          xfer += (*_iter27).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("per_exch_num_senders", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->per_exch_num_senders.size()));
    std::map< ::impala::TPlanNodeId, int32_t> ::const_iterator _iter28;
    for (_iter28 = this->per_exch_num_senders.begin(); _iter28 != this->per_exch_num_senders.end(); ++_iter28)
    {
      xfer += oprot->writeI32(_iter28->first);
      xfer += oprot->writeI32(_iter28->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("destinations", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->destinations.size()));
    std::vector<TPlanFragmentDestination> ::const_iterator _iter29;
    for (_iter29 = this->destinations.begin(); _iter29 != this->destinations.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.debug_node_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("debug_node_id", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->debug_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_phase) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("debug_phase", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->debug_phase);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b) {
  using ::std::swap;
  swap(a.query_id, b.query_id);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.per_node_scan_ranges, b.per_node_scan_ranges);
  swap(a.per_exch_num_senders, b.per_exch_num_senders);
  swap(a.destinations, b.destinations);
  swap(a.debug_node_id, b.debug_node_id);
  swap(a.debug_phase, b.debug_phase);
  swap(a.debug_action, b.debug_action);
  swap(a.__isset, b.__isset);
}

const char* TQueryGlobals::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TQueryGlobals::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TQueryGlobals::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_now_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->now_string);
          isset_now_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_now_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TQueryGlobals::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TQueryGlobals");

  ++fcnt;
  xfer += oprot->writeFieldBegin("now_string", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->now_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryGlobals &a, TQueryGlobals &b) {
  using ::std::swap;
  swap(a.now_string, b.now_string);
}

const char* TExecPlanFragmentParams::ascii_fingerprint = "52614A84C8B33D71799EAC0BA0BB5D3A";
const uint8_t TExecPlanFragmentParams::binary_fingerprint[16] = {0x52,0x61,0x4A,0x84,0xC8,0xB3,0x3D,0x71,0x79,0x9E,0xAC,0x0B,0xA0,0xBB,0x5D,0x3A};

uint32_t TExecPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->protocol_version = (ImpalaInternalServiceVersion::type)ecast30;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment.read(iprot);
          this->__isset.fragment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desc_tbl.read(iprot);
          this->__isset.desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->coord.read(iprot);
          this->__isset.coord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backend_num);
          this->__isset.backend_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_globals.read(iprot);
          this->__isset.query_globals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          this->__isset.query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExecPlanFragmentParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("fragment", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.desc_tbl) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("desc_tbl", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->desc_tbl.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.coord) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("coord", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->coord.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backend_num) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("backend_num", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->backend_num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_globals) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("query_globals", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->query_globals.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_options) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->query_options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment, b.fragment);
  swap(a.desc_tbl, b.desc_tbl);
  swap(a.params, b.params);
  swap(a.coord, b.coord);
  swap(a.backend_num, b.backend_num);
  swap(a.query_globals, b.query_globals);
  swap(a.query_options, b.query_options);
  swap(a.__isset, b.__isset);
}

const char* TExecPlanFragmentResult::ascii_fingerprint = "BA609E39B08A478BB74F0F877E3C5C4A";
const uint8_t TExecPlanFragmentResult::binary_fingerprint[16] = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

uint32_t TExecPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TExecPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExecPlanFragmentResult");

  if (this->__isset.status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TInsertExecStatus::ascii_fingerprint = "14FC82A619CDEFD6F41C2666F80D0A4E";
const uint8_t TInsertExecStatus::binary_fingerprint[16] = {0x14,0xFC,0x82,0xA6,0x19,0xCD,0xEF,0xD6,0xF4,0x1C,0x26,0x66,0xF8,0x0D,0x0A,0x4E};

uint32_t TInsertExecStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_files_to_move = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->num_appended_rows.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readString(_key36);
              int64_t& _val37 = this->num_appended_rows[_key36];
              xfer += iprot->readI64(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.num_appended_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->files_to_move.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _ktype39;
            ::apache::thrift::protocol::TType _vtype40;
            xfer += iprot->readMapBegin(_ktype39, _vtype40, _size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              std::string _key43;
              xfer += iprot->readString(_key43);
              std::string& _val44 = this->files_to_move[_key43];
              xfer += iprot->readString(_val44);
            }
            xfer += iprot->readMapEnd();
          }
          isset_files_to_move = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_files_to_move)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInsertExecStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TInsertExecStatus");

  if (this->__isset.num_appended_rows) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("num_appended_rows", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->num_appended_rows.size()));
      std::map<std::string, int64_t> ::const_iterator _iter45;
      for (_iter45 = this->num_appended_rows.begin(); _iter45 != this->num_appended_rows.end(); ++_iter45)
      {
        xfer += oprot->writeString(_iter45->first);
        xfer += oprot->writeI64(_iter45->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("files_to_move", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files_to_move.size()));
    std::map<std::string, std::string> ::const_iterator _iter46;
    for (_iter46 = this->files_to_move.begin(); _iter46 != this->files_to_move.end(); ++_iter46)
    {
      xfer += oprot->writeString(_iter46->first);
      xfer += oprot->writeString(_iter46->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertExecStatus &a, TInsertExecStatus &b) {
  using ::std::swap;
  swap(a.num_appended_rows, b.num_appended_rows);
  swap(a.files_to_move, b.files_to_move);
  swap(a.__isset, b.__isset);
}

const char* TReportExecStatusParams::ascii_fingerprint = "7E33EACA01416132EEEA03AB2A543AD7";
const uint8_t TReportExecStatusParams::binary_fingerprint[16] = {0x7E,0x33,0xEA,0xCA,0x01,0x41,0x61,0x32,0xEE,0xEA,0x03,0xAB,0x2A,0x54,0x3A,0xD7};

uint32_t TReportExecStatusParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast47;
          xfer += iprot->readI32(ecast47);
          this->protocol_version = (ImpalaInternalServiceVersion::type)ecast47;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_id.read(iprot);
          this->__isset.query_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backend_num);
          this->__isset.backend_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          this->__isset.fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->done);
          this->__isset.done = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->profile.read(iprot);
          this->__isset.profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insert_exec_status.read(iprot);
          this->__isset.insert_exec_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_log.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->error_log.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->error_log[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_log = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TReportExecStatusParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TReportExecStatusParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("query_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->query_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backend_num) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("backend_num", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->backend_num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fragment_instance_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.done) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("done", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->done);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.profile) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("profile", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->profile.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insert_exec_status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("insert_exec_status", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->insert_exec_status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_log) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("error_log", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_log.size()));
      std::vector<std::string> ::const_iterator _iter53;
      for (_iter53 = this->error_log.begin(); _iter53 != this->error_log.end(); ++_iter53)
      {
        xfer += oprot->writeString((*_iter53));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReportExecStatusParams &a, TReportExecStatusParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.query_id, b.query_id);
  swap(a.backend_num, b.backend_num);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.status, b.status);
  swap(a.done, b.done);
  swap(a.profile, b.profile);
  swap(a.insert_exec_status, b.insert_exec_status);
  swap(a.error_log, b.error_log);
  swap(a.__isset, b.__isset);
}

const char* TReportExecStatusResult::ascii_fingerprint = "BA609E39B08A478BB74F0F877E3C5C4A";
const uint8_t TReportExecStatusResult::binary_fingerprint[16] = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

uint32_t TReportExecStatusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TReportExecStatusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TReportExecStatusResult");

  if (this->__isset.status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TReportExecStatusResult &a, TReportExecStatusResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TCancelPlanFragmentParams::ascii_fingerprint = "7A58C455A7D49FCE68DC528A7710E205";
const uint8_t TCancelPlanFragmentParams::binary_fingerprint[16] = {0x7A,0x58,0xC4,0x55,0xA7,0xD4,0x9F,0xCE,0x68,0xDC,0x52,0x8A,0x77,0x10,0xE2,0x05};

uint32_t TCancelPlanFragmentParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->protocol_version = (ImpalaInternalServiceVersion::type)ecast54;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          this->__isset.fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCancelPlanFragmentParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCancelPlanFragmentParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fragment_instance_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.__isset, b.__isset);
}

const char* TCancelPlanFragmentResult::ascii_fingerprint = "BA609E39B08A478BB74F0F877E3C5C4A";
const uint8_t TCancelPlanFragmentResult::binary_fingerprint[16] = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

uint32_t TCancelPlanFragmentResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCancelPlanFragmentResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCancelPlanFragmentResult");

  if (this->__isset.status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* TTransmitDataParams::ascii_fingerprint = "ECE4CA3EAF435336ACF50B1B42112259";
const uint8_t TTransmitDataParams::binary_fingerprint[16] = {0xEC,0xE4,0xCA,0x3E,0xAF,0x43,0x53,0x36,0xAC,0xF5,0x0B,0x1B,0x42,0x11,0x22,0x59};

uint32_t TTransmitDataParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->protocol_version = (ImpalaInternalServiceVersion::type)ecast55;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dest_fragment_instance_id.read(iprot);
          this->__isset.dest_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          this->__isset.dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_batch.read(iprot);
          this->__isset.row_batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eos);
          this->__isset.eos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTransmitDataParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTransmitDataParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dest_fragment_instance_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("dest_fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dest_fragment_instance_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dest_node_id) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->dest_node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_batch) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("row_batch", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->row_batch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.eos) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("eos", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->eos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataParams &a, TTransmitDataParams &b) {
  using ::std::swap;
  swap(a.protocol_version, b.protocol_version);
  swap(a.dest_fragment_instance_id, b.dest_fragment_instance_id);
  swap(a.dest_node_id, b.dest_node_id);
  swap(a.row_batch, b.row_batch);
  swap(a.eos, b.eos);
  swap(a.__isset, b.__isset);
}

const char* TTransmitDataResult::ascii_fingerprint = "BA609E39B08A478BB74F0F877E3C5C4A";
const uint8_t TTransmitDataResult::binary_fingerprint[16] = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

uint32_t TTransmitDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTransmitDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTransmitDataResult");

  if (this->__isset.status) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTransmitDataResult &a, TTransmitDataResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

} // namespace
