/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Frontend_TYPES_H
#define Frontend_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Types_types.h"
#include "ImpalaInternalService_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "Descriptors_types.h"
#include "Data_types.h"
#include "cli_service_types.h"


namespace impala {

struct TFileFormat {
  enum type {
    PARQUETFILE = 0,
    RCFILE = 1,
    SEQUENCEFILE = 2,
    TEXTFILE = 3
  };
};

extern const std::map<int, const char*> _TFileFormat_VALUES_TO_NAMES;

struct TAlterTableType {
  enum type {
    ADD_REPLACE_COLUMNS = 0,
    ADD_PARTITION = 1,
    CHANGE_COLUMN = 2,
    DROP_COLUMN = 3,
    DROP_PARTITION = 4,
    RENAME_TABLE = 5,
    SET_FILE_FORMAT = 6,
    SET_LOCATION = 7
  };
};

extern const std::map<int, const char*> _TAlterTableType_VALUES_TO_NAMES;

struct TDdlType {
  enum type {
    SHOW_TABLES = 0,
    SHOW_DBS = 1,
    USE = 2,
    DESCRIBE = 3,
    ALTER_TABLE = 4,
    CREATE_DATABASE = 5,
    CREATE_TABLE = 6,
    CREATE_TABLE_LIKE = 7,
    DROP_DATABASE = 8,
    DROP_TABLE = 9
  };
};

extern const std::map<int, const char*> _TDdlType_VALUES_TO_NAMES;

struct TMetadataOpcode {
  enum type {
    GET_TYPE_INFO = 0,
    GET_CATALOGS = 1,
    GET_SCHEMAS = 2,
    GET_TABLES = 3,
    GET_TABLE_TYPES = 4,
    GET_COLUMNS = 5,
    GET_FUNCTIONS = 6
  };
};

extern const std::map<int, const char*> _TMetadataOpcode_VALUES_TO_NAMES;

typedef struct _TGetTablesParams__isset {
  _TGetTablesParams__isset() : db(false), pattern(false) {}
  bool db;
  bool pattern;
} _TGetTablesParams__isset;

class TGetTablesParams {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  TGetTablesParams() : db(), pattern() {
  }

  virtual ~TGetTablesParams() throw() {}

  std::string db;
  std::string pattern;

  _TGetTablesParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  bool operator == (const TGetTablesParams & rhs) const
  {
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    return true;
  }
  bool operator != (const TGetTablesParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesParams &a, TGetTablesParams &b);

typedef struct _TGetTablesResult__isset {
  _TGetTablesResult__isset() : tables(false) {}
  bool tables;
} _TGetTablesResult__isset;

class TGetTablesResult {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TGetTablesResult() {
  }

  virtual ~TGetTablesResult() throw() {}

  std::vector<std::string>  tables;

  _TGetTablesResult__isset __isset;

  void __set_tables(const std::vector<std::string> & val) {
    tables = val;
    __isset.tables = true;
  }

  bool operator == (const TGetTablesResult & rhs) const
  {
    if (!(tables == rhs.tables))
      return false;
    return true;
  }
  bool operator != (const TGetTablesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesResult &a, TGetTablesResult &b);

typedef struct _TGetDbsParams__isset {
  _TGetDbsParams__isset() : pattern(false) {}
  bool pattern;
} _TGetDbsParams__isset;

class TGetDbsParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TGetDbsParams() : pattern() {
  }

  virtual ~TGetDbsParams() throw() {}

  std::string pattern;

  _TGetDbsParams__isset __isset;

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  bool operator == (const TGetDbsParams & rhs) const
  {
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    return true;
  }
  bool operator != (const TGetDbsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDbsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDbsParams &a, TGetDbsParams &b);

typedef struct _TGetDbsResult__isset {
  _TGetDbsResult__isset() : dbs(false) {}
  bool dbs;
} _TGetDbsResult__isset;

class TGetDbsResult {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TGetDbsResult() {
  }

  virtual ~TGetDbsResult() throw() {}

  std::vector<std::string>  dbs;

  _TGetDbsResult__isset __isset;

  void __set_dbs(const std::vector<std::string> & val) {
    dbs = val;
    __isset.dbs = true;
  }

  bool operator == (const TGetDbsResult & rhs) const
  {
    if (!(dbs == rhs.dbs))
      return false;
    return true;
  }
  bool operator != (const TGetDbsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDbsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDbsResult &a, TGetDbsResult &b);


class TColumnDesc {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  TColumnDesc() : columnName(), columnType(( ::impala::TPrimitiveType::type)0) {
  }

  virtual ~TColumnDesc() throw() {}

  std::string columnName;
   ::impala::TPrimitiveType::type columnType;

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  void __set_columnType(const  ::impala::TPrimitiveType::type val) {
    columnType = val;
  }

  bool operator == (const TColumnDesc & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(columnType == rhs.columnType))
      return false;
    return true;
  }
  bool operator != (const TColumnDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnDesc &a, TColumnDesc &b);

typedef struct _TColumnDef__isset {
  _TColumnDef__isset() : comment(false) {}
  bool comment;
} _TColumnDef__isset;

class TColumnDef {
 public:

  static const char* ascii_fingerprint; // = "1A466928A838FDE756589DF00F1277D0";
  static const uint8_t binary_fingerprint[16]; // = {0x1A,0x46,0x69,0x28,0xA8,0x38,0xFD,0xE7,0x56,0x58,0x9D,0xF0,0x0F,0x12,0x77,0xD0};

  TColumnDef() : comment() {
  }

  virtual ~TColumnDef() throw() {}

  TColumnDesc columnDesc;
  std::string comment;

  _TColumnDef__isset __isset;

  void __set_columnDesc(const TColumnDesc& val) {
    columnDesc = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TColumnDef & rhs) const
  {
    if (!(columnDesc == rhs.columnDesc))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TColumnDef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnDef &a, TColumnDef &b);

typedef struct _TDescribeTableParams__isset {
  _TDescribeTableParams__isset() : db(false) {}
  bool db;
} _TDescribeTableParams__isset;

class TDescribeTableParams {
 public:

  static const char* ascii_fingerprint; // = "383E55F0D02199A3E52B9227E13A83A2";
  static const uint8_t binary_fingerprint[16]; // = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

  TDescribeTableParams() : db(), table_name() {
  }

  virtual ~TDescribeTableParams() throw() {}

  std::string db;
  std::string table_name;

  _TDescribeTableParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  bool operator == (const TDescribeTableParams & rhs) const
  {
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TDescribeTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescribeTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescribeTableParams &a, TDescribeTableParams &b);


class TDescribeTableResult {
 public:

  static const char* ascii_fingerprint; // = "310594E5EEC07991F491FF2D8123E958";
  static const uint8_t binary_fingerprint[16]; // = {0x31,0x05,0x94,0xE5,0xEE,0xC0,0x79,0x91,0xF4,0x91,0xFF,0x2D,0x81,0x23,0xE9,0x58};

  TDescribeTableResult() {
  }

  virtual ~TDescribeTableResult() throw() {}

  std::vector<TColumnDef>  columns;

  void __set_columns(const std::vector<TColumnDef> & val) {
    columns = val;
  }

  bool operator == (const TDescribeTableResult & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TDescribeTableResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescribeTableResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescribeTableResult &a, TDescribeTableResult &b);

typedef struct _TCreateDbParams__isset {
  _TCreateDbParams__isset() : comment(false), location(false), if_not_exists(false) {}
  bool comment;
  bool location;
  bool if_not_exists;
} _TCreateDbParams__isset;

class TCreateDbParams {
 public:

  static const char* ascii_fingerprint; // = "CAD4F97378DF2EFF77F23A193511C552";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0xD4,0xF9,0x73,0x78,0xDF,0x2E,0xFF,0x77,0xF2,0x3A,0x19,0x35,0x11,0xC5,0x52};

  TCreateDbParams() : db(), comment(), location(), if_not_exists(0) {
  }

  virtual ~TCreateDbParams() throw() {}

  std::string db;
  std::string comment;
  std::string location;
  bool if_not_exists;

  _TCreateDbParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
    __isset.if_not_exists = true;
  }

  bool operator == (const TCreateDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    return true;
  }
  bool operator != (const TCreateDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateDbParams &a, TCreateDbParams &b);


class TTableName {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TTableName() : db_name(), table_name() {
  }

  virtual ~TTableName() throw() {}

  std::string db_name;
  std::string table_name;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  bool operator == (const TTableName & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TTableName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableName &a, TTableName &b);

typedef struct _TTableRowFormat__isset {
  _TTableRowFormat__isset() : field_terminator(false), line_terminator(false), escaped_by(false) {}
  bool field_terminator;
  bool line_terminator;
  bool escaped_by;
} _TTableRowFormat__isset;

class TTableRowFormat {
 public:

  static const char* ascii_fingerprint; // = "B2C950B9C25B62CA02C2A8C700FEE26F";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0xC9,0x50,0xB9,0xC2,0x5B,0x62,0xCA,0x02,0xC2,0xA8,0xC7,0x00,0xFE,0xE2,0x6F};

  TTableRowFormat() : field_terminator(), line_terminator(), escaped_by() {
  }

  virtual ~TTableRowFormat() throw() {}

  std::string field_terminator;
  std::string line_terminator;
  std::string escaped_by;

  _TTableRowFormat__isset __isset;

  void __set_field_terminator(const std::string& val) {
    field_terminator = val;
    __isset.field_terminator = true;
  }

  void __set_line_terminator(const std::string& val) {
    line_terminator = val;
    __isset.line_terminator = true;
  }

  void __set_escaped_by(const std::string& val) {
    escaped_by = val;
    __isset.escaped_by = true;
  }

  bool operator == (const TTableRowFormat & rhs) const
  {
    if (__isset.field_terminator != rhs.__isset.field_terminator)
      return false;
    else if (__isset.field_terminator && !(field_terminator == rhs.field_terminator))
      return false;
    if (__isset.line_terminator != rhs.__isset.line_terminator)
      return false;
    else if (__isset.line_terminator && !(line_terminator == rhs.line_terminator))
      return false;
    if (__isset.escaped_by != rhs.__isset.escaped_by)
      return false;
    else if (__isset.escaped_by && !(escaped_by == rhs.escaped_by))
      return false;
    return true;
  }
  bool operator != (const TTableRowFormat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableRowFormat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableRowFormat &a, TTableRowFormat &b);


class TPartitionKeyValue {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TPartitionKeyValue() : name(), value() {
  }

  virtual ~TPartitionKeyValue() throw() {}

  std::string name;
  std::string value;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TPartitionKeyValue & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TPartitionKeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPartitionKeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b);


class TAlterTableRenameParams {
 public:

  static const char* ascii_fingerprint; // = "A756D3DBE614FB13F70BF7F7B6EB3D73";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

  TAlterTableRenameParams() {
  }

  virtual ~TAlterTableRenameParams() throw() {}

  TTableName new_table_name;

  void __set_new_table_name(const TTableName& val) {
    new_table_name = val;
  }

  bool operator == (const TAlterTableRenameParams & rhs) const
  {
    if (!(new_table_name == rhs.new_table_name))
      return false;
    return true;
  }
  bool operator != (const TAlterTableRenameParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableRenameParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableRenameParams &a, TAlterTableRenameParams &b);


class TAlterTableAddReplaceColsParams {
 public:

  static const char* ascii_fingerprint; // = "8A062F846D2647E1DF73D40439FB8C26";
  static const uint8_t binary_fingerprint[16]; // = {0x8A,0x06,0x2F,0x84,0x6D,0x26,0x47,0xE1,0xDF,0x73,0xD4,0x04,0x39,0xFB,0x8C,0x26};

  TAlterTableAddReplaceColsParams() : replace_existing_cols(0) {
  }

  virtual ~TAlterTableAddReplaceColsParams() throw() {}

  std::vector<TColumnDef>  columns;
  bool replace_existing_cols;

  void __set_columns(const std::vector<TColumnDef> & val) {
    columns = val;
  }

  void __set_replace_existing_cols(const bool val) {
    replace_existing_cols = val;
  }

  bool operator == (const TAlterTableAddReplaceColsParams & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(replace_existing_cols == rhs.replace_existing_cols))
      return false;
    return true;
  }
  bool operator != (const TAlterTableAddReplaceColsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableAddReplaceColsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableAddReplaceColsParams &a, TAlterTableAddReplaceColsParams &b);

typedef struct _TAlterTableAddPartitionParams__isset {
  _TAlterTableAddPartitionParams__isset() : location(false) {}
  bool location;
} _TAlterTableAddPartitionParams__isset;

class TAlterTableAddPartitionParams {
 public:

  static const char* ascii_fingerprint; // = "DDBF94C5C0804BF720FBDF685968F8B2";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0xBF,0x94,0xC5,0xC0,0x80,0x4B,0xF7,0x20,0xFB,0xDF,0x68,0x59,0x68,0xF8,0xB2};

  TAlterTableAddPartitionParams() : if_not_exists(0), location() {
  }

  virtual ~TAlterTableAddPartitionParams() throw() {}

  std::vector<TPartitionKeyValue>  partition_spec;
  bool if_not_exists;
  std::string location;

  _TAlterTableAddPartitionParams__isset __isset;

  void __set_partition_spec(const std::vector<TPartitionKeyValue> & val) {
    partition_spec = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const TAlterTableAddPartitionParams & rhs) const
  {
    if (!(partition_spec == rhs.partition_spec))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const TAlterTableAddPartitionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableAddPartitionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableAddPartitionParams &a, TAlterTableAddPartitionParams &b);


class TAlterTableDropColParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TAlterTableDropColParams() : col_name() {
  }

  virtual ~TAlterTableDropColParams() throw() {}

  std::string col_name;

  void __set_col_name(const std::string& val) {
    col_name = val;
  }

  bool operator == (const TAlterTableDropColParams & rhs) const
  {
    if (!(col_name == rhs.col_name))
      return false;
    return true;
  }
  bool operator != (const TAlterTableDropColParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableDropColParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableDropColParams &a, TAlterTableDropColParams &b);


class TAlterTableDropPartitionParams {
 public:

  static const char* ascii_fingerprint; // = "6F92A0A7B206615BE32209BF2E6A7ED1";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0x92,0xA0,0xA7,0xB2,0x06,0x61,0x5B,0xE3,0x22,0x09,0xBF,0x2E,0x6A,0x7E,0xD1};

  TAlterTableDropPartitionParams() : if_exists(0) {
  }

  virtual ~TAlterTableDropPartitionParams() throw() {}

  std::vector<TPartitionKeyValue>  partition_spec;
  bool if_exists;

  void __set_partition_spec(const std::vector<TPartitionKeyValue> & val) {
    partition_spec = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TAlterTableDropPartitionParams & rhs) const
  {
    if (!(partition_spec == rhs.partition_spec))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TAlterTableDropPartitionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableDropPartitionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableDropPartitionParams &a, TAlterTableDropPartitionParams &b);


class TAlterTableChangeColParams {
 public:

  static const char* ascii_fingerprint; // = "50D38FCE9C274638E6D49F7975E2CE6C";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0xD3,0x8F,0xCE,0x9C,0x27,0x46,0x38,0xE6,0xD4,0x9F,0x79,0x75,0xE2,0xCE,0x6C};

  TAlterTableChangeColParams() : col_name() {
  }

  virtual ~TAlterTableChangeColParams() throw() {}

  std::string col_name;
  TColumnDef new_col_def;

  void __set_col_name(const std::string& val) {
    col_name = val;
  }

  void __set_new_col_def(const TColumnDef& val) {
    new_col_def = val;
  }

  bool operator == (const TAlterTableChangeColParams & rhs) const
  {
    if (!(col_name == rhs.col_name))
      return false;
    if (!(new_col_def == rhs.new_col_def))
      return false;
    return true;
  }
  bool operator != (const TAlterTableChangeColParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableChangeColParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableChangeColParams &a, TAlterTableChangeColParams &b);

typedef struct _TAlterTableSetFileFormatParams__isset {
  _TAlterTableSetFileFormatParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetFileFormatParams__isset;

class TAlterTableSetFileFormatParams {
 public:

  static const char* ascii_fingerprint; // = "101E22EEE714785E462FCF6056B14937";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x1E,0x22,0xEE,0xE7,0x14,0x78,0x5E,0x46,0x2F,0xCF,0x60,0x56,0xB1,0x49,0x37};

  TAlterTableSetFileFormatParams() : file_format((TFileFormat::type)0) {
  }

  virtual ~TAlterTableSetFileFormatParams() throw() {}

  TFileFormat::type file_format;
  std::vector<TPartitionKeyValue>  partition_spec;

  _TAlterTableSetFileFormatParams__isset __isset;

  void __set_file_format(const TFileFormat::type val) {
    file_format = val;
  }

  void __set_partition_spec(const std::vector<TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetFileFormatParams & rhs) const
  {
    if (!(file_format == rhs.file_format))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetFileFormatParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetFileFormatParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetFileFormatParams &a, TAlterTableSetFileFormatParams &b);

typedef struct _TAlterTableSetLocationParams__isset {
  _TAlterTableSetLocationParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetLocationParams__isset;

class TAlterTableSetLocationParams {
 public:

  static const char* ascii_fingerprint; // = "620BD7B2710FAEABD876BE1FA48F69F0";
  static const uint8_t binary_fingerprint[16]; // = {0x62,0x0B,0xD7,0xB2,0x71,0x0F,0xAE,0xAB,0xD8,0x76,0xBE,0x1F,0xA4,0x8F,0x69,0xF0};

  TAlterTableSetLocationParams() : location() {
  }

  virtual ~TAlterTableSetLocationParams() throw() {}

  std::string location;
  std::vector<TPartitionKeyValue>  partition_spec;

  _TAlterTableSetLocationParams__isset __isset;

  void __set_location(const std::string& val) {
    location = val;
  }

  void __set_partition_spec(const std::vector<TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetLocationParams & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetLocationParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetLocationParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetLocationParams &a, TAlterTableSetLocationParams &b);

typedef struct _TAlterTableParams__isset {
  _TAlterTableParams__isset() : rename_params(false), add_replace_cols_params(false), add_partition_params(false), change_col_params(false), drop_col_params(false), drop_partition_params(false), set_file_format_params(false), set_location_params(false) {}
  bool rename_params;
  bool add_replace_cols_params;
  bool add_partition_params;
  bool change_col_params;
  bool drop_col_params;
  bool drop_partition_params;
  bool set_file_format_params;
  bool set_location_params;
} _TAlterTableParams__isset;

class TAlterTableParams {
 public:

  static const char* ascii_fingerprint; // = "8F534EA99B58367B90C40A9C386F9A64";
  static const uint8_t binary_fingerprint[16]; // = {0x8F,0x53,0x4E,0xA9,0x9B,0x58,0x36,0x7B,0x90,0xC4,0x0A,0x9C,0x38,0x6F,0x9A,0x64};

  TAlterTableParams() : alter_type((TAlterTableType::type)0) {
  }

  virtual ~TAlterTableParams() throw() {}

  TAlterTableType::type alter_type;
  TTableName table_name;
  TAlterTableRenameParams rename_params;
  TAlterTableAddReplaceColsParams add_replace_cols_params;
  TAlterTableAddPartitionParams add_partition_params;
  TAlterTableChangeColParams change_col_params;
  TAlterTableDropColParams drop_col_params;
  TAlterTableDropPartitionParams drop_partition_params;
  TAlterTableSetFileFormatParams set_file_format_params;
  TAlterTableSetLocationParams set_location_params;

  _TAlterTableParams__isset __isset;

  void __set_alter_type(const TAlterTableType::type val) {
    alter_type = val;
  }

  void __set_table_name(const TTableName& val) {
    table_name = val;
  }

  void __set_rename_params(const TAlterTableRenameParams& val) {
    rename_params = val;
    __isset.rename_params = true;
  }

  void __set_add_replace_cols_params(const TAlterTableAddReplaceColsParams& val) {
    add_replace_cols_params = val;
    __isset.add_replace_cols_params = true;
  }

  void __set_add_partition_params(const TAlterTableAddPartitionParams& val) {
    add_partition_params = val;
    __isset.add_partition_params = true;
  }

  void __set_change_col_params(const TAlterTableChangeColParams& val) {
    change_col_params = val;
    __isset.change_col_params = true;
  }

  void __set_drop_col_params(const TAlterTableDropColParams& val) {
    drop_col_params = val;
    __isset.drop_col_params = true;
  }

  void __set_drop_partition_params(const TAlterTableDropPartitionParams& val) {
    drop_partition_params = val;
    __isset.drop_partition_params = true;
  }

  void __set_set_file_format_params(const TAlterTableSetFileFormatParams& val) {
    set_file_format_params = val;
    __isset.set_file_format_params = true;
  }

  void __set_set_location_params(const TAlterTableSetLocationParams& val) {
    set_location_params = val;
    __isset.set_location_params = true;
  }

  bool operator == (const TAlterTableParams & rhs) const
  {
    if (!(alter_type == rhs.alter_type))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.rename_params != rhs.__isset.rename_params)
      return false;
    else if (__isset.rename_params && !(rename_params == rhs.rename_params))
      return false;
    if (__isset.add_replace_cols_params != rhs.__isset.add_replace_cols_params)
      return false;
    else if (__isset.add_replace_cols_params && !(add_replace_cols_params == rhs.add_replace_cols_params))
      return false;
    if (__isset.add_partition_params != rhs.__isset.add_partition_params)
      return false;
    else if (__isset.add_partition_params && !(add_partition_params == rhs.add_partition_params))
      return false;
    if (__isset.change_col_params != rhs.__isset.change_col_params)
      return false;
    else if (__isset.change_col_params && !(change_col_params == rhs.change_col_params))
      return false;
    if (__isset.drop_col_params != rhs.__isset.drop_col_params)
      return false;
    else if (__isset.drop_col_params && !(drop_col_params == rhs.drop_col_params))
      return false;
    if (__isset.drop_partition_params != rhs.__isset.drop_partition_params)
      return false;
    else if (__isset.drop_partition_params && !(drop_partition_params == rhs.drop_partition_params))
      return false;
    if (__isset.set_file_format_params != rhs.__isset.set_file_format_params)
      return false;
    else if (__isset.set_file_format_params && !(set_file_format_params == rhs.set_file_format_params))
      return false;
    if (__isset.set_location_params != rhs.__isset.set_location_params)
      return false;
    else if (__isset.set_location_params && !(set_location_params == rhs.set_location_params))
      return false;
    return true;
  }
  bool operator != (const TAlterTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableParams &a, TAlterTableParams &b);

typedef struct _TCreateTableLikeParams__isset {
  _TCreateTableLikeParams__isset() : file_format(false), comment(false), location(false) {}
  bool file_format;
  bool comment;
  bool location;
} _TCreateTableLikeParams__isset;

class TCreateTableLikeParams {
 public:

  static const char* ascii_fingerprint; // = "7BEC16F01713BB030792212D7EDE7C30";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xEC,0x16,0xF0,0x17,0x13,0xBB,0x03,0x07,0x92,0x21,0x2D,0x7E,0xDE,0x7C,0x30};

  TCreateTableLikeParams() : is_external(0), if_not_exists(0), owner(), file_format((TFileFormat::type)0), comment(), location() {
  }

  virtual ~TCreateTableLikeParams() throw() {}

  TTableName table_name;
  TTableName src_table_name;
  bool is_external;
  bool if_not_exists;
  std::string owner;
  TFileFormat::type file_format;
  std::string comment;
  std::string location;

  _TCreateTableLikeParams__isset __isset;

  void __set_table_name(const TTableName& val) {
    table_name = val;
  }

  void __set_src_table_name(const TTableName& val) {
    src_table_name = val;
  }

  void __set_is_external(const bool val) {
    is_external = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_file_format(const TFileFormat::type val) {
    file_format = val;
    __isset.file_format = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const TCreateTableLikeParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(src_table_name == rhs.src_table_name))
      return false;
    if (!(is_external == rhs.is_external))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (__isset.file_format != rhs.__isset.file_format)
      return false;
    else if (__isset.file_format && !(file_format == rhs.file_format))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const TCreateTableLikeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTableLikeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateTableLikeParams &a, TCreateTableLikeParams &b);

typedef struct _TCreateTableParams__isset {
  _TCreateTableParams__isset() : partition_columns(false), row_format(false), comment(false), location(false) {}
  bool partition_columns;
  bool row_format;
  bool comment;
  bool location;
} _TCreateTableParams__isset;

class TCreateTableParams {
 public:

  static const char* ascii_fingerprint; // = "A806D16923885311424912DE4D07024D";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x06,0xD1,0x69,0x23,0x88,0x53,0x11,0x42,0x49,0x12,0xDE,0x4D,0x07,0x02,0x4D};

  TCreateTableParams() : file_format((TFileFormat::type)0), is_external(0), if_not_exists(0), owner(), comment(), location() {
  }

  virtual ~TCreateTableParams() throw() {}

  TTableName table_name;
  std::vector<TColumnDef>  columns;
  std::vector<TColumnDef>  partition_columns;
  TFileFormat::type file_format;
  bool is_external;
  bool if_not_exists;
  std::string owner;
  TTableRowFormat row_format;
  std::string comment;
  std::string location;

  _TCreateTableParams__isset __isset;

  void __set_table_name(const TTableName& val) {
    table_name = val;
  }

  void __set_columns(const std::vector<TColumnDef> & val) {
    columns = val;
  }

  void __set_partition_columns(const std::vector<TColumnDef> & val) {
    partition_columns = val;
    __isset.partition_columns = true;
  }

  void __set_file_format(const TFileFormat::type val) {
    file_format = val;
  }

  void __set_is_external(const bool val) {
    is_external = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_row_format(const TTableRowFormat& val) {
    row_format = val;
    __isset.row_format = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const TCreateTableParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.partition_columns != rhs.__isset.partition_columns)
      return false;
    else if (__isset.partition_columns && !(partition_columns == rhs.partition_columns))
      return false;
    if (!(file_format == rhs.file_format))
      return false;
    if (!(is_external == rhs.is_external))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (__isset.row_format != rhs.__isset.row_format)
      return false;
    else if (__isset.row_format && !(row_format == rhs.row_format))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const TCreateTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateTableParams &a, TCreateTableParams &b);


class TDropDbParams {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  TDropDbParams() : db(), if_exists(0) {
  }

  virtual ~TDropDbParams() throw() {}

  std::string db;
  bool if_exists;

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TDropDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropDbParams &a, TDropDbParams &b);


class TDropTableParams {
 public:

  static const char* ascii_fingerprint; // = "790158CF902C527D004C99E60A2E4B2E";
  static const uint8_t binary_fingerprint[16]; // = {0x79,0x01,0x58,0xCF,0x90,0x2C,0x52,0x7D,0x00,0x4C,0x99,0xE6,0x0A,0x2E,0x4B,0x2E};

  TDropTableParams() : if_exists(0) {
  }

  virtual ~TDropTableParams() throw() {}

  TTableName table_name;
  bool if_exists;

  void __set_table_name(const TTableName& val) {
    table_name = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TDropTableParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropTableParams &a, TDropTableParams &b);


class TSessionState {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TSessionState() : database(), user() {
  }

  virtual ~TSessionState() throw() {}

  std::string database;
  std::string user;

  void __set_database(const std::string& val) {
    database = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  bool operator == (const TSessionState & rhs) const
  {
    if (!(database == rhs.database))
      return false;
    if (!(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const TSessionState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSessionState &a, TSessionState &b);


class TClientRequest {
 public:

  static const char* ascii_fingerprint; // = "AEEBB37EB85D30D8B07D47726C1C3058";
  static const uint8_t binary_fingerprint[16]; // = {0xAE,0xEB,0xB3,0x7E,0xB8,0x5D,0x30,0xD8,0xB0,0x7D,0x47,0x72,0x6C,0x1C,0x30,0x58};

  TClientRequest() : stmt() {
  }

  virtual ~TClientRequest() throw() {}

  std::string stmt;
   ::impala::TQueryOptions queryOptions;
  TSessionState sessionState;

  void __set_stmt(const std::string& val) {
    stmt = val;
  }

  void __set_queryOptions(const  ::impala::TQueryOptions& val) {
    queryOptions = val;
  }

  void __set_sessionState(const TSessionState& val) {
    sessionState = val;
  }

  bool operator == (const TClientRequest & rhs) const
  {
    if (!(stmt == rhs.stmt))
      return false;
    if (!(queryOptions == rhs.queryOptions))
      return false;
    if (!(sessionState == rhs.sessionState))
      return false;
    return true;
  }
  bool operator != (const TClientRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClientRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TClientRequest &a, TClientRequest &b);

typedef struct _TShowDbsParams__isset {
  _TShowDbsParams__isset() : show_pattern(false) {}
  bool show_pattern;
} _TShowDbsParams__isset;

class TShowDbsParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TShowDbsParams() : show_pattern() {
  }

  virtual ~TShowDbsParams() throw() {}

  std::string show_pattern;

  _TShowDbsParams__isset __isset;

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowDbsParams & rhs) const
  {
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowDbsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowDbsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowDbsParams &a, TShowDbsParams &b);

typedef struct _TShowTablesParams__isset {
  _TShowTablesParams__isset() : db(false), show_pattern(false) {}
  bool db;
  bool show_pattern;
} _TShowTablesParams__isset;

class TShowTablesParams {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  TShowTablesParams() : db(), show_pattern() {
  }

  virtual ~TShowTablesParams() throw() {}

  std::string db;
  std::string show_pattern;

  _TShowTablesParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowTablesParams & rhs) const
  {
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowTablesParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowTablesParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowTablesParams &a, TShowTablesParams &b);


class TUseDbParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TUseDbParams() : db() {
  }

  virtual ~TUseDbParams() throw() {}

  std::string db;

  void __set_db(const std::string& val) {
    db = val;
  }

  bool operator == (const TUseDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    return true;
  }
  bool operator != (const TUseDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUseDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUseDbParams &a, TUseDbParams &b);


class TExplainResult {
 public:

  static const char* ascii_fingerprint; // = "33B1AC796556B5D176326D0D2FCA5450";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0xB1,0xAC,0x79,0x65,0x56,0xB5,0xD1,0x76,0x32,0x6D,0x0D,0x2F,0xCA,0x54,0x50};

  TExplainResult() {
  }

  virtual ~TExplainResult() throw() {}

  std::vector< ::impala::TResultRow>  results;

  void __set_results(const std::vector< ::impala::TResultRow> & val) {
    results = val;
  }

  bool operator == (const TExplainResult & rhs) const
  {
    if (!(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TExplainResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExplainResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExplainResult &a, TExplainResult &b);


class TResultSetMetadata {
 public:

  static const char* ascii_fingerprint; // = "D50C2F9EC7D3B85649634752C0F64DC3";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x0C,0x2F,0x9E,0xC7,0xD3,0xB8,0x56,0x49,0x63,0x47,0x52,0xC0,0xF6,0x4D,0xC3};

  TResultSetMetadata() {
  }

  virtual ~TResultSetMetadata() throw() {}

  std::vector<TColumnDesc>  columnDescs;

  void __set_columnDescs(const std::vector<TColumnDesc> & val) {
    columnDescs = val;
  }

  bool operator == (const TResultSetMetadata & rhs) const
  {
    if (!(columnDescs == rhs.columnDescs))
      return false;
    return true;
  }
  bool operator != (const TResultSetMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResultSetMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TResultSetMetadata &a, TResultSetMetadata &b);


class TCatalogUpdate {
 public:

  static const char* ascii_fingerprint; // = "845BD8C082A6EDFE58B66C91C7C24C6E";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x5B,0xD8,0xC0,0x82,0xA6,0xED,0xFE,0x58,0xB6,0x6C,0x91,0xC7,0xC2,0x4C,0x6E};

  TCatalogUpdate() : target_table(), db_name() {
  }

  virtual ~TCatalogUpdate() throw() {}

  std::string target_table;
  std::string db_name;
  std::set<std::string>  created_partitions;

  void __set_target_table(const std::string& val) {
    target_table = val;
  }

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_created_partitions(const std::set<std::string> & val) {
    created_partitions = val;
  }

  bool operator == (const TCatalogUpdate & rhs) const
  {
    if (!(target_table == rhs.target_table))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(created_partitions == rhs.created_partitions))
      return false;
    return true;
  }
  bool operator != (const TCatalogUpdate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalogUpdate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalogUpdate &a, TCatalogUpdate &b);


class TFinalizeParams {
 public:

  static const char* ascii_fingerprint; // = "B7080D97FBE64A05254F705FB1FADA7F";
  static const uint8_t binary_fingerprint[16]; // = {0xB7,0x08,0x0D,0x97,0xFB,0xE6,0x4A,0x05,0x25,0x4F,0x70,0x5F,0xB1,0xFA,0xDA,0x7F};

  TFinalizeParams() : is_overwrite(0), hdfs_base_dir(), table_name(), table_db() {
  }

  virtual ~TFinalizeParams() throw() {}

  bool is_overwrite;
  std::string hdfs_base_dir;
  std::string table_name;
  std::string table_db;

  void __set_is_overwrite(const bool val) {
    is_overwrite = val;
  }

  void __set_hdfs_base_dir(const std::string& val) {
    hdfs_base_dir = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_table_db(const std::string& val) {
    table_db = val;
  }

  bool operator == (const TFinalizeParams & rhs) const
  {
    if (!(is_overwrite == rhs.is_overwrite))
      return false;
    if (!(hdfs_base_dir == rhs.hdfs_base_dir))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    return true;
  }
  bool operator != (const TFinalizeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFinalizeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFinalizeParams &a, TFinalizeParams &b);

typedef struct _TQueryExecRequest__isset {
  _TQueryExecRequest__isset() : desc_tbl(false), dest_fragment_idx(false), per_node_scan_ranges(false), result_set_metadata(false), finalize_params(false), query_plan(false) {}
  bool desc_tbl;
  bool dest_fragment_idx;
  bool per_node_scan_ranges;
  bool result_set_metadata;
  bool finalize_params;
  bool query_plan;
} _TQueryExecRequest__isset;

class TQueryExecRequest {
 public:

  static const char* ascii_fingerprint; // = "1D4C017A9088C19C6BE21EB79C551FB1";
  static const uint8_t binary_fingerprint[16]; // = {0x1D,0x4C,0x01,0x7A,0x90,0x88,0xC1,0x9C,0x6B,0xE2,0x1E,0xB7,0x9C,0x55,0x1F,0xB1};

  TQueryExecRequest() : query_plan(), stmt_type(( ::impala::TStmtType::type)0) {
  }

  virtual ~TQueryExecRequest() throw() {}

   ::impala::TDescriptorTable desc_tbl;
  std::vector< ::impala::TPlanFragment>  fragments;
  std::vector<int32_t>  dest_fragment_idx;
  std::map< ::impala::TPlanNodeId, std::vector< ::impala::TScanRangeLocations> >  per_node_scan_ranges;
  TResultSetMetadata result_set_metadata;
  TFinalizeParams finalize_params;
   ::impala::TQueryGlobals query_globals;
  std::string query_plan;
   ::impala::TStmtType::type stmt_type;

  _TQueryExecRequest__isset __isset;

  void __set_desc_tbl(const  ::impala::TDescriptorTable& val) {
    desc_tbl = val;
    __isset.desc_tbl = true;
  }

  void __set_fragments(const std::vector< ::impala::TPlanFragment> & val) {
    fragments = val;
  }

  void __set_dest_fragment_idx(const std::vector<int32_t> & val) {
    dest_fragment_idx = val;
    __isset.dest_fragment_idx = true;
  }

  void __set_per_node_scan_ranges(const std::map< ::impala::TPlanNodeId, std::vector< ::impala::TScanRangeLocations> > & val) {
    per_node_scan_ranges = val;
    __isset.per_node_scan_ranges = true;
  }

  void __set_result_set_metadata(const TResultSetMetadata& val) {
    result_set_metadata = val;
    __isset.result_set_metadata = true;
  }

  void __set_finalize_params(const TFinalizeParams& val) {
    finalize_params = val;
    __isset.finalize_params = true;
  }

  void __set_query_globals(const  ::impala::TQueryGlobals& val) {
    query_globals = val;
  }

  void __set_query_plan(const std::string& val) {
    query_plan = val;
    __isset.query_plan = true;
  }

  void __set_stmt_type(const  ::impala::TStmtType::type val) {
    stmt_type = val;
  }

  bool operator == (const TQueryExecRequest & rhs) const
  {
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (!(fragments == rhs.fragments))
      return false;
    if (__isset.dest_fragment_idx != rhs.__isset.dest_fragment_idx)
      return false;
    else if (__isset.dest_fragment_idx && !(dest_fragment_idx == rhs.dest_fragment_idx))
      return false;
    if (__isset.per_node_scan_ranges != rhs.__isset.per_node_scan_ranges)
      return false;
    else if (__isset.per_node_scan_ranges && !(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (__isset.result_set_metadata != rhs.__isset.result_set_metadata)
      return false;
    else if (__isset.result_set_metadata && !(result_set_metadata == rhs.result_set_metadata))
      return false;
    if (__isset.finalize_params != rhs.__isset.finalize_params)
      return false;
    else if (__isset.finalize_params && !(finalize_params == rhs.finalize_params))
      return false;
    if (!(query_globals == rhs.query_globals))
      return false;
    if (__isset.query_plan != rhs.__isset.query_plan)
      return false;
    else if (__isset.query_plan && !(query_plan == rhs.query_plan))
      return false;
    if (!(stmt_type == rhs.stmt_type))
      return false;
    return true;
  }
  bool operator != (const TQueryExecRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryExecRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryExecRequest &a, TQueryExecRequest &b);

typedef struct _TDdlExecRequest__isset {
  _TDdlExecRequest__isset() : use_db_params(false), describe_table_params(false), show_dbs_params(false), show_tables_params(false), alter_table_params(false), create_db_params(false), create_table_params(false), create_table_like_params(false), drop_db_params(false), drop_table_params(false) {}
  bool use_db_params;
  bool describe_table_params;
  bool show_dbs_params;
  bool show_tables_params;
  bool alter_table_params;
  bool create_db_params;
  bool create_table_params;
  bool create_table_like_params;
  bool drop_db_params;
  bool drop_table_params;
} _TDdlExecRequest__isset;

class TDdlExecRequest {
 public:

  static const char* ascii_fingerprint; // = "0CD54BC026F4A54FCCF01B6B6F3FADA6";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0xD5,0x4B,0xC0,0x26,0xF4,0xA5,0x4F,0xCC,0xF0,0x1B,0x6B,0x6F,0x3F,0xAD,0xA6};

  TDdlExecRequest() : ddl_type((TDdlType::type)0) {
  }

  virtual ~TDdlExecRequest() throw() {}

  TDdlType::type ddl_type;
  TUseDbParams use_db_params;
  TDescribeTableParams describe_table_params;
  TShowDbsParams show_dbs_params;
  TShowTablesParams show_tables_params;
  TAlterTableParams alter_table_params;
  TCreateDbParams create_db_params;
  TCreateTableParams create_table_params;
  TCreateTableLikeParams create_table_like_params;
  TDropDbParams drop_db_params;
  TDropTableParams drop_table_params;

  _TDdlExecRequest__isset __isset;

  void __set_ddl_type(const TDdlType::type val) {
    ddl_type = val;
  }

  void __set_use_db_params(const TUseDbParams& val) {
    use_db_params = val;
    __isset.use_db_params = true;
  }

  void __set_describe_table_params(const TDescribeTableParams& val) {
    describe_table_params = val;
    __isset.describe_table_params = true;
  }

  void __set_show_dbs_params(const TShowDbsParams& val) {
    show_dbs_params = val;
    __isset.show_dbs_params = true;
  }

  void __set_show_tables_params(const TShowTablesParams& val) {
    show_tables_params = val;
    __isset.show_tables_params = true;
  }

  void __set_alter_table_params(const TAlterTableParams& val) {
    alter_table_params = val;
    __isset.alter_table_params = true;
  }

  void __set_create_db_params(const TCreateDbParams& val) {
    create_db_params = val;
    __isset.create_db_params = true;
  }

  void __set_create_table_params(const TCreateTableParams& val) {
    create_table_params = val;
    __isset.create_table_params = true;
  }

  void __set_create_table_like_params(const TCreateTableLikeParams& val) {
    create_table_like_params = val;
    __isset.create_table_like_params = true;
  }

  void __set_drop_db_params(const TDropDbParams& val) {
    drop_db_params = val;
    __isset.drop_db_params = true;
  }

  void __set_drop_table_params(const TDropTableParams& val) {
    drop_table_params = val;
    __isset.drop_table_params = true;
  }

  bool operator == (const TDdlExecRequest & rhs) const
  {
    if (!(ddl_type == rhs.ddl_type))
      return false;
    if (__isset.use_db_params != rhs.__isset.use_db_params)
      return false;
    else if (__isset.use_db_params && !(use_db_params == rhs.use_db_params))
      return false;
    if (__isset.describe_table_params != rhs.__isset.describe_table_params)
      return false;
    else if (__isset.describe_table_params && !(describe_table_params == rhs.describe_table_params))
      return false;
    if (__isset.show_dbs_params != rhs.__isset.show_dbs_params)
      return false;
    else if (__isset.show_dbs_params && !(show_dbs_params == rhs.show_dbs_params))
      return false;
    if (__isset.show_tables_params != rhs.__isset.show_tables_params)
      return false;
    else if (__isset.show_tables_params && !(show_tables_params == rhs.show_tables_params))
      return false;
    if (__isset.alter_table_params != rhs.__isset.alter_table_params)
      return false;
    else if (__isset.alter_table_params && !(alter_table_params == rhs.alter_table_params))
      return false;
    if (__isset.create_db_params != rhs.__isset.create_db_params)
      return false;
    else if (__isset.create_db_params && !(create_db_params == rhs.create_db_params))
      return false;
    if (__isset.create_table_params != rhs.__isset.create_table_params)
      return false;
    else if (__isset.create_table_params && !(create_table_params == rhs.create_table_params))
      return false;
    if (__isset.create_table_like_params != rhs.__isset.create_table_like_params)
      return false;
    else if (__isset.create_table_like_params && !(create_table_like_params == rhs.create_table_like_params))
      return false;
    if (__isset.drop_db_params != rhs.__isset.drop_db_params)
      return false;
    else if (__isset.drop_db_params && !(drop_db_params == rhs.drop_db_params))
      return false;
    if (__isset.drop_table_params != rhs.__isset.drop_table_params)
      return false;
    else if (__isset.drop_table_params && !(drop_table_params == rhs.drop_table_params))
      return false;
    return true;
  }
  bool operator != (const TDdlExecRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDdlExecRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDdlExecRequest &a, TDdlExecRequest &b);

typedef struct _TMetadataOpRequest__isset {
  _TMetadataOpRequest__isset() : get_info_req(false), get_type_info_req(false), get_catalogs_req(false), get_schemas_req(false), get_tables_req(false), get_table_types_req(false), get_columns_req(false), get_functions_req(false) {}
  bool get_info_req;
  bool get_type_info_req;
  bool get_catalogs_req;
  bool get_schemas_req;
  bool get_tables_req;
  bool get_table_types_req;
  bool get_columns_req;
  bool get_functions_req;
} _TMetadataOpRequest__isset;

class TMetadataOpRequest {
 public:

  static const char* ascii_fingerprint; // = "4F3B3DA03A312B25CD984C98432A660A";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0x3B,0x3D,0xA0,0x3A,0x31,0x2B,0x25,0xCD,0x98,0x4C,0x98,0x43,0x2A,0x66,0x0A};

  TMetadataOpRequest() : opcode((TMetadataOpcode::type)0) {
  }

  virtual ~TMetadataOpRequest() throw() {}

  TMetadataOpcode::type opcode;
   ::apache::hive::service::cli::thrift::TGetInfoReq get_info_req;
   ::apache::hive::service::cli::thrift::TGetTypeInfoReq get_type_info_req;
   ::apache::hive::service::cli::thrift::TGetCatalogsReq get_catalogs_req;
   ::apache::hive::service::cli::thrift::TGetSchemasReq get_schemas_req;
   ::apache::hive::service::cli::thrift::TGetTablesReq get_tables_req;
   ::apache::hive::service::cli::thrift::TGetTableTypesReq get_table_types_req;
   ::apache::hive::service::cli::thrift::TGetColumnsReq get_columns_req;
   ::apache::hive::service::cli::thrift::TGetFunctionsReq get_functions_req;

  _TMetadataOpRequest__isset __isset;

  void __set_opcode(const TMetadataOpcode::type val) {
    opcode = val;
  }

  void __set_get_info_req(const  ::apache::hive::service::cli::thrift::TGetInfoReq& val) {
    get_info_req = val;
    __isset.get_info_req = true;
  }

  void __set_get_type_info_req(const  ::apache::hive::service::cli::thrift::TGetTypeInfoReq& val) {
    get_type_info_req = val;
    __isset.get_type_info_req = true;
  }

  void __set_get_catalogs_req(const  ::apache::hive::service::cli::thrift::TGetCatalogsReq& val) {
    get_catalogs_req = val;
    __isset.get_catalogs_req = true;
  }

  void __set_get_schemas_req(const  ::apache::hive::service::cli::thrift::TGetSchemasReq& val) {
    get_schemas_req = val;
    __isset.get_schemas_req = true;
  }

  void __set_get_tables_req(const  ::apache::hive::service::cli::thrift::TGetTablesReq& val) {
    get_tables_req = val;
    __isset.get_tables_req = true;
  }

  void __set_get_table_types_req(const  ::apache::hive::service::cli::thrift::TGetTableTypesReq& val) {
    get_table_types_req = val;
    __isset.get_table_types_req = true;
  }

  void __set_get_columns_req(const  ::apache::hive::service::cli::thrift::TGetColumnsReq& val) {
    get_columns_req = val;
    __isset.get_columns_req = true;
  }

  void __set_get_functions_req(const  ::apache::hive::service::cli::thrift::TGetFunctionsReq& val) {
    get_functions_req = val;
    __isset.get_functions_req = true;
  }

  bool operator == (const TMetadataOpRequest & rhs) const
  {
    if (!(opcode == rhs.opcode))
      return false;
    if (__isset.get_info_req != rhs.__isset.get_info_req)
      return false;
    else if (__isset.get_info_req && !(get_info_req == rhs.get_info_req))
      return false;
    if (__isset.get_type_info_req != rhs.__isset.get_type_info_req)
      return false;
    else if (__isset.get_type_info_req && !(get_type_info_req == rhs.get_type_info_req))
      return false;
    if (__isset.get_catalogs_req != rhs.__isset.get_catalogs_req)
      return false;
    else if (__isset.get_catalogs_req && !(get_catalogs_req == rhs.get_catalogs_req))
      return false;
    if (__isset.get_schemas_req != rhs.__isset.get_schemas_req)
      return false;
    else if (__isset.get_schemas_req && !(get_schemas_req == rhs.get_schemas_req))
      return false;
    if (__isset.get_tables_req != rhs.__isset.get_tables_req)
      return false;
    else if (__isset.get_tables_req && !(get_tables_req == rhs.get_tables_req))
      return false;
    if (__isset.get_table_types_req != rhs.__isset.get_table_types_req)
      return false;
    else if (__isset.get_table_types_req && !(get_table_types_req == rhs.get_table_types_req))
      return false;
    if (__isset.get_columns_req != rhs.__isset.get_columns_req)
      return false;
    else if (__isset.get_columns_req && !(get_columns_req == rhs.get_columns_req))
      return false;
    if (__isset.get_functions_req != rhs.__isset.get_functions_req)
      return false;
    else if (__isset.get_functions_req && !(get_functions_req == rhs.get_functions_req))
      return false;
    return true;
  }
  bool operator != (const TMetadataOpRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMetadataOpRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMetadataOpRequest &a, TMetadataOpRequest &b);


class TMetadataOpResponse {
 public:

  static const char* ascii_fingerprint; // = "AA4955CB4C4B7C6D8052EE00C6221E71";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x49,0x55,0xCB,0x4C,0x4B,0x7C,0x6D,0x80,0x52,0xEE,0x00,0xC6,0x22,0x1E,0x71};

  TMetadataOpResponse() {
  }

  virtual ~TMetadataOpResponse() throw() {}

  TResultSetMetadata result_set_metadata;
  std::vector< ::impala::TResultRow>  results;

  void __set_result_set_metadata(const TResultSetMetadata& val) {
    result_set_metadata = val;
  }

  void __set_results(const std::vector< ::impala::TResultRow> & val) {
    results = val;
  }

  bool operator == (const TMetadataOpResponse & rhs) const
  {
    if (!(result_set_metadata == rhs.result_set_metadata))
      return false;
    if (!(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TMetadataOpResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMetadataOpResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMetadataOpResponse &a, TMetadataOpResponse &b);

typedef struct _TExecRequest__isset {
  _TExecRequest__isset() : query_exec_request(false), ddl_exec_request(false), result_set_metadata(false), explain_result(false) {}
  bool query_exec_request;
  bool ddl_exec_request;
  bool result_set_metadata;
  bool explain_result;
} _TExecRequest__isset;

class TExecRequest {
 public:

  static const char* ascii_fingerprint; // = "1C016EECD0A86E8488A03ED102679100";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0x01,0x6E,0xEC,0xD0,0xA8,0x6E,0x84,0x88,0xA0,0x3E,0xD1,0x02,0x67,0x91,0x00};

  TExecRequest() : stmt_type(( ::impala::TStmtType::type)0) {
  }

  virtual ~TExecRequest() throw() {}

   ::impala::TStmtType::type stmt_type;
   ::impala::TQueryOptions query_options;
  TQueryExecRequest query_exec_request;
  TDdlExecRequest ddl_exec_request;
  TResultSetMetadata result_set_metadata;
  TExplainResult explain_result;

  _TExecRequest__isset __isset;

  void __set_stmt_type(const  ::impala::TStmtType::type val) {
    stmt_type = val;
  }

  void __set_query_options(const  ::impala::TQueryOptions& val) {
    query_options = val;
  }

  void __set_query_exec_request(const TQueryExecRequest& val) {
    query_exec_request = val;
    __isset.query_exec_request = true;
  }

  void __set_ddl_exec_request(const TDdlExecRequest& val) {
    ddl_exec_request = val;
    __isset.ddl_exec_request = true;
  }

  void __set_result_set_metadata(const TResultSetMetadata& val) {
    result_set_metadata = val;
    __isset.result_set_metadata = true;
  }

  void __set_explain_result(const TExplainResult& val) {
    explain_result = val;
    __isset.explain_result = true;
  }

  bool operator == (const TExecRequest & rhs) const
  {
    if (!(stmt_type == rhs.stmt_type))
      return false;
    if (!(query_options == rhs.query_options))
      return false;
    if (__isset.query_exec_request != rhs.__isset.query_exec_request)
      return false;
    else if (__isset.query_exec_request && !(query_exec_request == rhs.query_exec_request))
      return false;
    if (__isset.ddl_exec_request != rhs.__isset.ddl_exec_request)
      return false;
    else if (__isset.ddl_exec_request && !(ddl_exec_request == rhs.ddl_exec_request))
      return false;
    if (__isset.result_set_metadata != rhs.__isset.result_set_metadata)
      return false;
    else if (__isset.result_set_metadata && !(result_set_metadata == rhs.result_set_metadata))
      return false;
    if (__isset.explain_result != rhs.__isset.explain_result)
      return false;
    else if (__isset.explain_result && !(explain_result == rhs.explain_result))
      return false;
    return true;
  }
  bool operator != (const TExecRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecRequest &a, TExecRequest &b);

} // namespace

#endif
