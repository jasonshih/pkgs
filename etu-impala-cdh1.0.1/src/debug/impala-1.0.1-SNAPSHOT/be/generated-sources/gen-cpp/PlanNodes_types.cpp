/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PlanNodes_types.h"

#include <algorithm>

namespace impala {

int _kTPlanNodeTypeValues[] = {
  TPlanNodeType::HDFS_SCAN_NODE,
  TPlanNodeType::HBASE_SCAN_NODE,
  TPlanNodeType::HASH_JOIN_NODE,
  TPlanNodeType::AGGREGATION_NODE,
  TPlanNodeType::SORT_NODE,
  TPlanNodeType::EXCHANGE_NODE,
  TPlanNodeType::MERGE_NODE,
  TPlanNodeType::SELECT_NODE
};
const char* _kTPlanNodeTypeNames[] = {
  "HDFS_SCAN_NODE",
  "HBASE_SCAN_NODE",
  "HASH_JOIN_NODE",
  "AGGREGATION_NODE",
  "SORT_NODE",
  "EXCHANGE_NODE",
  "MERGE_NODE",
  "SELECT_NODE"
};
const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTPlanNodeTypeValues, _kTPlanNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTExecNodePhaseValues[] = {
  TExecNodePhase::PREPARE,
  TExecNodePhase::OPEN,
  TExecNodePhase::GETNEXT,
  TExecNodePhase::CLOSE,
  TExecNodePhase::INVALID
};
const char* _kTExecNodePhaseNames[] = {
  "PREPARE",
  "OPEN",
  "GETNEXT",
  "CLOSE",
  "INVALID"
};
const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTExecNodePhaseValues, _kTExecNodePhaseNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDebugActionValues[] = {
  TDebugAction::WAIT,
  TDebugAction::FAIL
};
const char* _kTDebugActionNames[] = {
  "WAIT",
  "FAIL"
};
const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDebugActionValues, _kTDebugActionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTJoinOpValues[] = {
  TJoinOp::INNER_JOIN,
  TJoinOp::LEFT_OUTER_JOIN,
  TJoinOp::LEFT_SEMI_JOIN,
  TJoinOp::RIGHT_OUTER_JOIN,
  TJoinOp::FULL_OUTER_JOIN
};
const char* _kTJoinOpNames[] = {
  "INNER_JOIN",
  "LEFT_OUTER_JOIN",
  "LEFT_SEMI_JOIN",
  "RIGHT_OUTER_JOIN",
  "FULL_OUTER_JOIN"
};
const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTJoinOpValues, _kTJoinOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* THdfsFileSplit::ascii_fingerprint = "9118FDD77343DD231D97C424A53D2DCF";
const uint8_t THdfsFileSplit::binary_fingerprint[16] = {0x91,0x18,0xFD,0xD7,0x73,0x43,0xDD,0x23,0x1D,0x97,0xC4,0x24,0xA5,0x3D,0x2D,0xCF};

uint32_t THdfsFileSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_path = false;
  bool isset_offset = false;
  bool isset_length = false;
  bool isset_partition_id = false;
  bool isset_file_length = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          isset_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partition_id);
          isset_partition_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->file_length);
          isset_file_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsFileSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsFileSplit");

  ++fcnt;
  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("partition_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->partition_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("file_length", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->file_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsFileSplit &a, THdfsFileSplit &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.offset, b.offset);
  swap(a.length, b.length);
  swap(a.partition_id, b.partition_id);
  swap(a.file_length, b.file_length);
}

const char* THBaseKeyRange::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t THBaseKeyRange::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t THBaseKeyRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stopKey);
          this->__isset.stopKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THBaseKeyRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THBaseKeyRange");

  if (this->__isset.startKey) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopKey) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("stopKey", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->stopKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THBaseKeyRange &a, THBaseKeyRange &b) {
  using ::std::swap;
  swap(a.startKey, b.startKey);
  swap(a.stopKey, b.stopKey);
  swap(a.__isset, b.__isset);
}

const char* TScanRange::ascii_fingerprint = "3375FEB6FC792611F5B83B498340EAA2";
const uint8_t TScanRange::binary_fingerprint[16] = {0x33,0x75,0xFE,0xB6,0xFC,0x79,0x26,0x11,0xF5,0xB8,0x3B,0x49,0x83,0x40,0xEA,0xA2};

uint32_t TScanRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_file_split.read(iprot);
          this->__isset.hdfs_file_split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_key_range.read(iprot);
          this->__isset.hbase_key_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScanRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TScanRange");

  if (this->__isset.hdfs_file_split) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hdfs_file_split", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hdfs_file_split.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_key_range) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hbase_key_range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->hbase_key_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScanRange &a, TScanRange &b) {
  using ::std::swap;
  swap(a.hdfs_file_split, b.hdfs_file_split);
  swap(a.hbase_key_range, b.hbase_key_range);
  swap(a.__isset, b.__isset);
}

const char* THdfsScanNode::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t THdfsScanNode::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t THdfsScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THdfsScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THdfsScanNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THdfsScanNode &a, THdfsScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
}

const char* THBaseFilter::ascii_fingerprint = "AC16F1200213405F9A9267FCBF95F39A";
const uint8_t THBaseFilter::binary_fingerprint[16] = {0xAC,0x16,0xF1,0x20,0x02,0x13,0x40,0x5F,0x9A,0x92,0x67,0xFC,0xBF,0x95,0xF3,0x9A};

uint32_t THBaseFilter::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_op_ordinal = false;
  bool isset_filter_constant = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->op_ordinal);
          isset_op_ordinal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter_constant);
          isset_filter_constant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_op_ordinal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filter_constant)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THBaseFilter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THBaseFilter");

  ++fcnt;
  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->family);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->qualifier);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("op_ordinal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->op_ordinal);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("filter_constant", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->filter_constant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THBaseFilter &a, THBaseFilter &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.op_ordinal, b.op_ordinal);
  swap(a.filter_constant, b.filter_constant);
}

const char* THBaseScanNode::ascii_fingerprint = "98D0FFE72423C9A6FE4369BC7E6BE5E8";
const uint8_t THBaseScanNode::binary_fingerprint[16] = {0x98,0xD0,0xFF,0xE7,0x24,0x23,0xC9,0xA6,0xFE,0x43,0x69,0xBC,0x7E,0x6B,0xE5,0xE8};

uint32_t THBaseScanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->filters.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->filters[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THBaseScanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THBaseScanNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filters) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->filters.size()));
      std::vector<THBaseFilter> ::const_iterator _iter5;
      for (_iter5 = this->filters.begin(); _iter5 != this->filters.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THBaseScanNode &a, THBaseScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.filters, b.filters);
  swap(a.__isset, b.__isset);
}

const char* TEqJoinCondition::ascii_fingerprint = "CD533BBF3EEC17C7873771BAD707F4EA";
const uint8_t TEqJoinCondition::binary_fingerprint[16] = {0xCD,0x53,0x3B,0xBF,0x3E,0xEC,0x17,0xC7,0x87,0x37,0x71,0xBA,0xD7,0x07,0xF4,0xEA};

uint32_t TEqJoinCondition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_left = false;
  bool isset_right = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->left.read(iprot);
          isset_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->right.read(iprot);
          isset_right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_left)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_right)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TEqJoinCondition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TEqJoinCondition");

  ++fcnt;
  xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->left.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("right", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->right.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TEqJoinCondition &a, TEqJoinCondition &b) {
  using ::std::swap;
  swap(a.left, b.left);
  swap(a.right, b.right);
}

const char* THashJoinNode::ascii_fingerprint = "EB56449A44F659DFDED99DDC19014B7D";
const uint8_t THashJoinNode::binary_fingerprint[16] = {0xEB,0x56,0x44,0x9A,0x44,0xF6,0x59,0xDF,0xDE,0xD9,0x9D,0xDC,0x19,0x01,0x4B,0x7D};

uint32_t THashJoinNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_join_op = false;
  bool isset_eq_join_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->join_op = (TJoinOp::type)ecast6;
          isset_join_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eq_join_conjuncts.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->eq_join_conjuncts.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += this->eq_join_conjuncts[_i11].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_eq_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->other_join_conjuncts.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->other_join_conjuncts[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_join_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eq_join_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THashJoinNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("THashJoinNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("join_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->join_op);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("eq_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->eq_join_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter17;
    for (_iter17 = this->eq_join_conjuncts.begin(); _iter17 != this->eq_join_conjuncts.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter18;
      for (_iter18 = this->other_join_conjuncts.begin(); _iter18 != this->other_join_conjuncts.end(); ++_iter18)
      {
        xfer += (*_iter18).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THashJoinNode &a, THashJoinNode &b) {
  using ::std::swap;
  swap(a.join_op, b.join_op);
  swap(a.eq_join_conjuncts, b.eq_join_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.__isset, b.__isset);
}

const char* TAggregationNode::ascii_fingerprint = "0B0DB5CE2212FEEA509FD27E4D4E644B";
const uint8_t TAggregationNode::binary_fingerprint[16] = {0x0B,0x0D,0xB5,0xCE,0x22,0x12,0xFE,0xEA,0x50,0x9F,0xD2,0x7E,0x4D,0x4E,0x64,0x4B};

uint32_t TAggregationNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aggregate_exprs = false;
  bool isset_agg_tuple_id = false;
  bool isset_need_finalize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grouping_exprs.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->grouping_exprs.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->grouping_exprs[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.grouping_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_exprs.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->aggregate_exprs.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->aggregate_exprs[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->agg_tuple_id);
          isset_agg_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_finalize);
          isset_need_finalize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aggregate_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_agg_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_need_finalize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregationNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAggregationNode");

  if (this->__isset.grouping_exprs) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("grouping_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->grouping_exprs.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter29;
      for (_iter29 = this->grouping_exprs.begin(); _iter29 != this->grouping_exprs.end(); ++_iter29)
      {
        xfer += (*_iter29).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("aggregate_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter30;
    for (_iter30 = this->aggregate_exprs.begin(); _iter30 != this->aggregate_exprs.end(); ++_iter30)
    {
      xfer += (*_iter30).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("agg_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->agg_tuple_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("need_finalize", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->need_finalize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregationNode &a, TAggregationNode &b) {
  using ::std::swap;
  swap(a.grouping_exprs, b.grouping_exprs);
  swap(a.aggregate_exprs, b.aggregate_exprs);
  swap(a.agg_tuple_id, b.agg_tuple_id);
  swap(a.need_finalize, b.need_finalize);
  swap(a.__isset, b.__isset);
}

const char* TSortNode::ascii_fingerprint = "EF6D81A0F991D37567BCC21A03A3FD9E";
const uint8_t TSortNode::binary_fingerprint[16] = {0xEF,0x6D,0x81,0xA0,0xF9,0x91,0xD3,0x75,0x67,0xBC,0xC2,0x1A,0x03,0xA3,0xFD,0x9E};

uint32_t TSortNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ordering_exprs = false;
  bool isset_is_asc_order = false;
  bool isset_use_top_n = false;
  bool isset_is_default_limit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->ordering_exprs.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->ordering_exprs[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->is_asc_order.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readBool(this->is_asc_order[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_top_n);
          isset_use_top_n = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_default_limit);
          isset_is_default_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ordering_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_asc_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_use_top_n)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_default_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSortNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TSortNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter41;
    for (_iter41 = this->ordering_exprs.begin(); _iter41 != this->ordering_exprs.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
    std::vector<bool> ::const_iterator _iter42;
    for (_iter42 = this->is_asc_order.begin(); _iter42 != this->is_asc_order.end(); ++_iter42)
    {
      xfer += oprot->writeBool((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("use_top_n", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->use_top_n);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_default_limit", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_default_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSortNode &a, TSortNode &b) {
  using ::std::swap;
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.use_top_n, b.use_top_n);
  swap(a.is_default_limit, b.is_default_limit);
}

const char* TMergeNode::ascii_fingerprint = "8E1DC5B8DF21B2E0BE4333A4EC5BC79D";
const uint8_t TMergeNode::binary_fingerprint[16] = {0x8E,0x1D,0xC5,0xB8,0xDF,0x21,0xB2,0xE0,0xBE,0x43,0x33,0xA4,0xEC,0x5B,0xC7,0x9D};

uint32_t TMergeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->result_expr_lists.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              {
                this->result_expr_lists[_i47].clear();
                uint32_t _size48;
                ::apache::thrift::protocol::TType _etype51;
                xfer += iprot->readListBegin(_etype51, _size48);
                this->result_expr_lists[_i47].resize(_size48);
                uint32_t _i52;
                for (_i52 = 0; _i52 < _size48; ++_i52)
                {
                  xfer += this->result_expr_lists[_i47][_i52].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->const_expr_lists.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              {
                this->const_expr_lists[_i57].clear();
                uint32_t _size58;
                ::apache::thrift::protocol::TType _etype61;
                xfer += iprot->readListBegin(_etype61, _size58);
                this->const_expr_lists[_i57].resize(_size58);
                uint32_t _i62;
                for (_i62 = 0; _i62 < _size58; ++_i62)
                {
                  xfer += this->const_expr_lists[_i57][_i62].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMergeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TMergeNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::impala::TExpr> > ::const_iterator _iter63;
    for (_iter63 = this->result_expr_lists.begin(); _iter63 != this->result_expr_lists.end(); ++_iter63)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter63).size()));
        std::vector< ::impala::TExpr> ::const_iterator _iter64;
        for (_iter64 = (*_iter63).begin(); _iter64 != (*_iter63).end(); ++_iter64)
        {
          xfer += (*_iter64).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::impala::TExpr> > ::const_iterator _iter65;
    for (_iter65 = this->const_expr_lists.begin(); _iter65 != this->const_expr_lists.end(); ++_iter65)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter65).size()));
        std::vector< ::impala::TExpr> ::const_iterator _iter66;
        for (_iter66 = (*_iter65).begin(); _iter66 != (*_iter65).end(); ++_iter66)
        {
          xfer += (*_iter66).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMergeNode &a, TMergeNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
}

const char* TExchangeNode::ascii_fingerprint = "A803C54EAD95E24D90C5E66FB98EA72B";
const uint8_t TExchangeNode::binary_fingerprint[16] = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

uint32_t TExchangeNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_input_row_tuples = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_row_tuples.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->input_row_tuples.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readI32(this->input_row_tuples[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          isset_input_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_input_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExchangeNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExchangeNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("input_row_tuples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->input_row_tuples.size()));
    std::vector< ::impala::TTupleId> ::const_iterator _iter72;
    for (_iter72 = this->input_row_tuples.begin(); _iter72 != this->input_row_tuples.end(); ++_iter72)
    {
      xfer += oprot->writeI32((*_iter72));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExchangeNode &a, TExchangeNode &b) {
  using ::std::swap;
  swap(a.input_row_tuples, b.input_row_tuples);
}

const char* TPlanNode::ascii_fingerprint = "9D0AA257F0B26E3819E7A5646EC10909";
const uint8_t TPlanNode::binary_fingerprint[16] = {0x9D,0x0A,0xA2,0x57,0xF0,0xB2,0x6E,0x38,0x19,0xE7,0xA5,0x64,0x6E,0xC1,0x09,0x09};

uint32_t TPlanNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_node_type = false;
  bool isset_num_children = false;
  bool isset_limit = false;
  bool isset_row_tuples = false;
  bool isset_nullable_tuples = false;
  bool isset_compact_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->node_type = (TPlanNodeType::type)ecast73;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_tuples.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->row_tuples.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readI32(this->row_tuples[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nullable_tuples.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->nullable_tuples.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readBool(this->nullable_tuples[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nullable_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conjuncts.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->conjuncts.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->conjuncts[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compact_data);
          isset_compact_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_scan_node.read(iprot);
          this->__isset.hdfs_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_scan_node.read(iprot);
          this->__isset.hbase_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash_join_node.read(iprot);
          this->__isset.hash_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_node.read(iprot);
          this->__isset.agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_node.read(iprot);
          this->__isset.sort_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->merge_node.read(iprot);
          this->__isset.merge_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exchange_node.read(iprot);
          this->__isset.exchange_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullable_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compact_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlanNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPlanNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("row_tuples", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->row_tuples.size()));
    std::vector< ::impala::TTupleId> ::const_iterator _iter89;
    for (_iter89 = this->row_tuples.begin(); _iter89 != this->row_tuples.end(); ++_iter89)
    {
      xfer += oprot->writeI32((*_iter89));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("nullable_tuples", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nullable_tuples.size()));
    std::vector<bool> ::const_iterator _iter90;
    for (_iter90 = this->nullable_tuples.begin(); _iter90 != this->nullable_tuples.end(); ++_iter90)
    {
      xfer += oprot->writeBool((*_iter90));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.conjuncts) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("conjuncts", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter91;
      for (_iter91 = this->conjuncts.begin(); _iter91 != this->conjuncts.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("compact_data", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->compact_data);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hdfs_scan_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hdfs_scan_node", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->hdfs_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_scan_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hbase_scan_node", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->hbase_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hash_join_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("hash_join_node", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->hash_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agg_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("agg_node", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("sort_node", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->sort_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("merge_node", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->merge_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchange_node) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("exchange_node", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->exchange_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlanNode &a, TPlanNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.node_type, b.node_type);
  swap(a.num_children, b.num_children);
  swap(a.limit, b.limit);
  swap(a.row_tuples, b.row_tuples);
  swap(a.nullable_tuples, b.nullable_tuples);
  swap(a.conjuncts, b.conjuncts);
  swap(a.compact_data, b.compact_data);
  swap(a.hdfs_scan_node, b.hdfs_scan_node);
  swap(a.hbase_scan_node, b.hbase_scan_node);
  swap(a.hash_join_node, b.hash_join_node);
  swap(a.agg_node, b.agg_node);
  swap(a.sort_node, b.sort_node);
  swap(a.merge_node, b.merge_node);
  swap(a.exchange_node, b.exchange_node);
  swap(a.__isset, b.__isset);
}

const char* TPlan::ascii_fingerprint = "371CA622539C2D47699AB0E525454D36";
const uint8_t TPlan::binary_fingerprint[16] = {0x37,0x1C,0xA6,0x22,0x53,0x9C,0x2D,0x47,0x69,0x9A,0xB0,0xE5,0x25,0x45,0x4D,0x36};

uint32_t TPlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->nodes.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->nodes[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPlan");

  ++fcnt;
  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TPlanNode> ::const_iterator _iter97;
    for (_iter97 = this->nodes.begin(); _iter97 != this->nodes.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPlan &a, TPlan &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

} // namespace
