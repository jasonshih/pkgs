/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Exprs_TYPES_H
#define Exprs_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Types_types.h"
#include "Opcodes_types.h"


namespace impala {

struct TExprNodeType {
  enum type {
    AGG_EXPR = 0,
    ARITHMETIC_EXPR = 1,
    BINARY_PRED = 2,
    BOOL_LITERAL = 3,
    CASE_EXPR = 4,
    CAST_EXPR = 5,
    COMPOUND_PRED = 6,
    DATE_LITERAL = 7,
    FLOAT_LITERAL = 8,
    FUNCTION_CALL = 9,
    INT_LITERAL = 10,
    IN_PRED = 11,
    IS_NULL_PRED = 12,
    LIKE_PRED = 13,
    LITERAL_PRED = 14,
    NULL_LITERAL = 15,
    SLOT_REF = 16,
    STRING_LITERAL = 17,
    TUPLE_IS_NULL_PRED = 18
  };
};

extern const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES;

struct TAggregationOp {
  enum type {
    INVALID = 0,
    COUNT = 1,
    MAX = 2,
    DISTINCT_PC = 3,
    MERGE_PC = 4,
    DISTINCT_PCSA = 5,
    MERGE_PCSA = 6,
    MIN = 7,
    SUM = 8
  };
};

extern const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES;


class TAggregateExpr {
 public:

  static const char* ascii_fingerprint; // = "0CAF0E42754E65C5573E4F81DB5F43FD";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0xAF,0x0E,0x42,0x75,0x4E,0x65,0xC5,0x57,0x3E,0x4F,0x81,0xDB,0x5F,0x43,0xFD};

  TAggregateExpr() : is_star(0), is_distinct(0), op((TAggregationOp::type)0) {
  }

  virtual ~TAggregateExpr() throw() {}

  bool is_star;
  bool is_distinct;
  TAggregationOp::type op;

  void __set_is_star(const bool val) {
    is_star = val;
  }

  void __set_is_distinct(const bool val) {
    is_distinct = val;
  }

  void __set_op(const TAggregationOp::type val) {
    op = val;
  }

  bool operator == (const TAggregateExpr & rhs) const
  {
    if (!(is_star == rhs.is_star))
      return false;
    if (!(is_distinct == rhs.is_distinct))
      return false;
    if (!(op == rhs.op))
      return false;
    return true;
  }
  bool operator != (const TAggregateExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregateExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregateExpr &a, TAggregateExpr &b);


class TBoolLiteral {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TBoolLiteral() : value(0) {
  }

  virtual ~TBoolLiteral() throw() {}

  bool value;

  void __set_value(const bool val) {
    value = val;
  }

  bool operator == (const TBoolLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolLiteral &a, TBoolLiteral &b);


class TCaseExpr {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TCaseExpr() : has_case_expr(0), has_else_expr(0) {
  }

  virtual ~TCaseExpr() throw() {}

  bool has_case_expr;
  bool has_else_expr;

  void __set_has_case_expr(const bool val) {
    has_case_expr = val;
  }

  void __set_has_else_expr(const bool val) {
    has_else_expr = val;
  }

  bool operator == (const TCaseExpr & rhs) const
  {
    if (!(has_case_expr == rhs.has_case_expr))
      return false;
    if (!(has_else_expr == rhs.has_else_expr))
      return false;
    return true;
  }
  bool operator != (const TCaseExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCaseExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCaseExpr &a, TCaseExpr &b);


class TDateLiteral {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TDateLiteral() : value(0) {
  }

  virtual ~TDateLiteral() throw() {}

   ::impala::TTimestamp value;

  void __set_value(const  ::impala::TTimestamp val) {
    value = val;
  }

  bool operator == (const TDateLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDateLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDateLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDateLiteral &a, TDateLiteral &b);


class TFloatLiteral {
 public:

  static const char* ascii_fingerprint; // = "66FFB53A2471384C03D9F21F6FACA58F";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

  TFloatLiteral() : value(0) {
  }

  virtual ~TFloatLiteral() throw() {}

  double value;

  void __set_value(const double val) {
    value = val;
  }

  bool operator == (const TFloatLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TFloatLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFloatLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFloatLiteral &a, TFloatLiteral &b);


class TIntLiteral {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TIntLiteral() : value(0) {
  }

  virtual ~TIntLiteral() throw() {}

  int64_t value;

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const TIntLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TIntLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIntLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIntLiteral &a, TIntLiteral &b);


class TInPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TInPredicate() : is_not_in(0) {
  }

  virtual ~TInPredicate() throw() {}

  bool is_not_in;

  void __set_is_not_in(const bool val) {
    is_not_in = val;
  }

  bool operator == (const TInPredicate & rhs) const
  {
    if (!(is_not_in == rhs.is_not_in))
      return false;
    return true;
  }
  bool operator != (const TInPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInPredicate &a, TInPredicate &b);


class TIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  TIsNullPredicate() : is_not_null(0) {
  }

  virtual ~TIsNullPredicate() throw() {}

  bool is_not_null;

  void __set_is_not_null(const bool val) {
    is_not_null = val;
  }

  bool operator == (const TIsNullPredicate & rhs) const
  {
    if (!(is_not_null == rhs.is_not_null))
      return false;
    return true;
  }
  bool operator != (const TIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TIsNullPredicate &a, TIsNullPredicate &b);


class TLikePredicate {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TLikePredicate() : escape_char() {
  }

  virtual ~TLikePredicate() throw() {}

  std::string escape_char;

  void __set_escape_char(const std::string& val) {
    escape_char = val;
  }

  bool operator == (const TLikePredicate & rhs) const
  {
    if (!(escape_char == rhs.escape_char))
      return false;
    return true;
  }
  bool operator != (const TLikePredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLikePredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLikePredicate &a, TLikePredicate &b);


class TLiteralPredicate {
 public:

  static const char* ascii_fingerprint; // = "403F0C4586060E367DA428DD09C59C9C";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

  TLiteralPredicate() : value(0), is_null(0) {
  }

  virtual ~TLiteralPredicate() throw() {}

  bool value;
  bool is_null;

  void __set_value(const bool val) {
    value = val;
  }

  void __set_is_null(const bool val) {
    is_null = val;
  }

  bool operator == (const TLiteralPredicate & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(is_null == rhs.is_null))
      return false;
    return true;
  }
  bool operator != (const TLiteralPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLiteralPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLiteralPredicate &a, TLiteralPredicate &b);


class TTupleIsNullPredicate {
 public:

  static const char* ascii_fingerprint; // = "A803C54EAD95E24D90C5E66FB98EA72B";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

  TTupleIsNullPredicate() {
  }

  virtual ~TTupleIsNullPredicate() throw() {}

  std::vector< ::impala::TTupleId>  tuple_ids;

  void __set_tuple_ids(const std::vector< ::impala::TTupleId> & val) {
    tuple_ids = val;
  }

  bool operator == (const TTupleIsNullPredicate & rhs) const
  {
    if (!(tuple_ids == rhs.tuple_ids))
      return false;
    return true;
  }
  bool operator != (const TTupleIsNullPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleIsNullPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b);


class TSlotRef {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TSlotRef() : slot_id(0) {
  }

  virtual ~TSlotRef() throw() {}

   ::impala::TSlotId slot_id;

  void __set_slot_id(const  ::impala::TSlotId val) {
    slot_id = val;
  }

  bool operator == (const TSlotRef & rhs) const
  {
    if (!(slot_id == rhs.slot_id))
      return false;
    return true;
  }
  bool operator != (const TSlotRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSlotRef &a, TSlotRef &b);


class TStringLiteral {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TStringLiteral() : value() {
  }

  virtual ~TStringLiteral() throw() {}

  std::string value;

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TStringLiteral & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringLiteral &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringLiteral & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringLiteral &a, TStringLiteral &b);

typedef struct _TExprNode__isset {
  _TExprNode__isset() : opcode(false), agg_expr(false), bool_literal(false), case_expr(false), date_literal(false), float_literal(false), int_literal(false), in_predicate(false), is_null_pred(false), like_pred(false), literal_pred(false), slot_ref(false), string_literal(false), tuple_is_null_pred(false) {}
  bool opcode;
  bool agg_expr;
  bool bool_literal;
  bool case_expr;
  bool date_literal;
  bool float_literal;
  bool int_literal;
  bool in_predicate;
  bool is_null_pred;
  bool like_pred;
  bool literal_pred;
  bool slot_ref;
  bool string_literal;
  bool tuple_is_null_pred;
} _TExprNode__isset;

class TExprNode {
 public:

  static const char* ascii_fingerprint; // = "A9F2B8D465AC204F0A7F0CA0C087C86A";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0xF2,0xB8,0xD4,0x65,0xAC,0x20,0x4F,0x0A,0x7F,0x0C,0xA0,0xC0,0x87,0xC8,0x6A};

  TExprNode() : node_type((TExprNodeType::type)0), type(( ::impala::TPrimitiveType::type)0), opcode(( ::impala::TExprOpcode::type)0), num_children(0) {
  }

  virtual ~TExprNode() throw() {}

  TExprNodeType::type node_type;
   ::impala::TPrimitiveType::type type;
   ::impala::TExprOpcode::type opcode;
  int32_t num_children;
  TAggregateExpr agg_expr;
  TBoolLiteral bool_literal;
  TCaseExpr case_expr;
  TDateLiteral date_literal;
  TFloatLiteral float_literal;
  TIntLiteral int_literal;
  TInPredicate in_predicate;
  TIsNullPredicate is_null_pred;
  TLikePredicate like_pred;
  TLiteralPredicate literal_pred;
  TSlotRef slot_ref;
  TStringLiteral string_literal;
  TTupleIsNullPredicate tuple_is_null_pred;

  _TExprNode__isset __isset;

  void __set_node_type(const TExprNodeType::type val) {
    node_type = val;
  }

  void __set_type(const  ::impala::TPrimitiveType::type val) {
    type = val;
  }

  void __set_opcode(const  ::impala::TExprOpcode::type val) {
    opcode = val;
    __isset.opcode = true;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_agg_expr(const TAggregateExpr& val) {
    agg_expr = val;
    __isset.agg_expr = true;
  }

  void __set_bool_literal(const TBoolLiteral& val) {
    bool_literal = val;
    __isset.bool_literal = true;
  }

  void __set_case_expr(const TCaseExpr& val) {
    case_expr = val;
    __isset.case_expr = true;
  }

  void __set_date_literal(const TDateLiteral& val) {
    date_literal = val;
    __isset.date_literal = true;
  }

  void __set_float_literal(const TFloatLiteral& val) {
    float_literal = val;
    __isset.float_literal = true;
  }

  void __set_int_literal(const TIntLiteral& val) {
    int_literal = val;
    __isset.int_literal = true;
  }

  void __set_in_predicate(const TInPredicate& val) {
    in_predicate = val;
    __isset.in_predicate = true;
  }

  void __set_is_null_pred(const TIsNullPredicate& val) {
    is_null_pred = val;
    __isset.is_null_pred = true;
  }

  void __set_like_pred(const TLikePredicate& val) {
    like_pred = val;
    __isset.like_pred = true;
  }

  void __set_literal_pred(const TLiteralPredicate& val) {
    literal_pred = val;
    __isset.literal_pred = true;
  }

  void __set_slot_ref(const TSlotRef& val) {
    slot_ref = val;
    __isset.slot_ref = true;
  }

  void __set_string_literal(const TStringLiteral& val) {
    string_literal = val;
    __isset.string_literal = true;
  }

  void __set_tuple_is_null_pred(const TTupleIsNullPredicate& val) {
    tuple_is_null_pred = val;
    __isset.tuple_is_null_pred = true;
  }

  bool operator == (const TExprNode & rhs) const
  {
    if (!(node_type == rhs.node_type))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.opcode != rhs.__isset.opcode)
      return false;
    else if (__isset.opcode && !(opcode == rhs.opcode))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (__isset.agg_expr != rhs.__isset.agg_expr)
      return false;
    else if (__isset.agg_expr && !(agg_expr == rhs.agg_expr))
      return false;
    if (__isset.bool_literal != rhs.__isset.bool_literal)
      return false;
    else if (__isset.bool_literal && !(bool_literal == rhs.bool_literal))
      return false;
    if (__isset.case_expr != rhs.__isset.case_expr)
      return false;
    else if (__isset.case_expr && !(case_expr == rhs.case_expr))
      return false;
    if (__isset.date_literal != rhs.__isset.date_literal)
      return false;
    else if (__isset.date_literal && !(date_literal == rhs.date_literal))
      return false;
    if (__isset.float_literal != rhs.__isset.float_literal)
      return false;
    else if (__isset.float_literal && !(float_literal == rhs.float_literal))
      return false;
    if (__isset.int_literal != rhs.__isset.int_literal)
      return false;
    else if (__isset.int_literal && !(int_literal == rhs.int_literal))
      return false;
    if (__isset.in_predicate != rhs.__isset.in_predicate)
      return false;
    else if (__isset.in_predicate && !(in_predicate == rhs.in_predicate))
      return false;
    if (__isset.is_null_pred != rhs.__isset.is_null_pred)
      return false;
    else if (__isset.is_null_pred && !(is_null_pred == rhs.is_null_pred))
      return false;
    if (__isset.like_pred != rhs.__isset.like_pred)
      return false;
    else if (__isset.like_pred && !(like_pred == rhs.like_pred))
      return false;
    if (__isset.literal_pred != rhs.__isset.literal_pred)
      return false;
    else if (__isset.literal_pred && !(literal_pred == rhs.literal_pred))
      return false;
    if (__isset.slot_ref != rhs.__isset.slot_ref)
      return false;
    else if (__isset.slot_ref && !(slot_ref == rhs.slot_ref))
      return false;
    if (__isset.string_literal != rhs.__isset.string_literal)
      return false;
    else if (__isset.string_literal && !(string_literal == rhs.string_literal))
      return false;
    if (__isset.tuple_is_null_pred != rhs.__isset.tuple_is_null_pred)
      return false;
    else if (__isset.tuple_is_null_pred && !(tuple_is_null_pred == rhs.tuple_is_null_pred))
      return false;
    return true;
  }
  bool operator != (const TExprNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExprNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExprNode &a, TExprNode &b);


class TExpr {
 public:

  static const char* ascii_fingerprint; // = "9D47FA18B80D57FB20B9D57BFF9B95CF";
  static const uint8_t binary_fingerprint[16]; // = {0x9D,0x47,0xFA,0x18,0xB8,0x0D,0x57,0xFB,0x20,0xB9,0xD5,0x7B,0xFF,0x9B,0x95,0xCF};

  TExpr() {
  }

  virtual ~TExpr() throw() {}

  std::vector<TExprNode>  nodes;

  void __set_nodes(const std::vector<TExprNode> & val) {
    nodes = val;
  }

  bool operator == (const TExpr & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExpr &a, TExpr &b);

} // namespace

#endif
