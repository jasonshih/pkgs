/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_H
#define PlanNodes_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Exprs_types.h"
#include "Types_types.h"


namespace impala {

struct TPlanNodeType {
  enum type {
    HDFS_SCAN_NODE = 0,
    HBASE_SCAN_NODE = 1,
    HASH_JOIN_NODE = 2,
    AGGREGATION_NODE = 3,
    SORT_NODE = 4,
    EXCHANGE_NODE = 5,
    MERGE_NODE = 6,
    SELECT_NODE = 7
  };
};

extern const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES;

struct TExecNodePhase {
  enum type {
    PREPARE = 0,
    OPEN = 1,
    GETNEXT = 2,
    CLOSE = 3,
    INVALID = 4
  };
};

extern const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES;

struct TDebugAction {
  enum type {
    WAIT = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES;

struct TJoinOp {
  enum type {
    INNER_JOIN = 0,
    LEFT_OUTER_JOIN = 1,
    LEFT_SEMI_JOIN = 2,
    RIGHT_OUTER_JOIN = 3,
    FULL_OUTER_JOIN = 4
  };
};

extern const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES;


class THdfsFileSplit {
 public:

  static const char* ascii_fingerprint; // = "9118FDD77343DD231D97C424A53D2DCF";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0x18,0xFD,0xD7,0x73,0x43,0xDD,0x23,0x1D,0x97,0xC4,0x24,0xA5,0x3D,0x2D,0xCF};

  THdfsFileSplit() : path(), offset(0), length(0), partition_id(0), file_length(0) {
  }

  virtual ~THdfsFileSplit() throw() {}

  std::string path;
  int64_t offset;
  int64_t length;
  int64_t partition_id;
  int64_t file_length;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_partition_id(const int64_t val) {
    partition_id = val;
  }

  void __set_file_length(const int64_t val) {
    file_length = val;
  }

  bool operator == (const THdfsFileSplit & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(partition_id == rhs.partition_id))
      return false;
    if (!(file_length == rhs.file_length))
      return false;
    return true;
  }
  bool operator != (const THdfsFileSplit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileSplit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileSplit &a, THdfsFileSplit &b);

typedef struct _THBaseKeyRange__isset {
  _THBaseKeyRange__isset() : startKey(false), stopKey(false) {}
  bool startKey;
  bool stopKey;
} _THBaseKeyRange__isset;

class THBaseKeyRange {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  THBaseKeyRange() : startKey(), stopKey() {
  }

  virtual ~THBaseKeyRange() throw() {}

  std::string startKey;
  std::string stopKey;

  _THBaseKeyRange__isset __isset;

  void __set_startKey(const std::string& val) {
    startKey = val;
    __isset.startKey = true;
  }

  void __set_stopKey(const std::string& val) {
    stopKey = val;
    __isset.stopKey = true;
  }

  bool operator == (const THBaseKeyRange & rhs) const
  {
    if (__isset.startKey != rhs.__isset.startKey)
      return false;
    else if (__isset.startKey && !(startKey == rhs.startKey))
      return false;
    if (__isset.stopKey != rhs.__isset.stopKey)
      return false;
    else if (__isset.stopKey && !(stopKey == rhs.stopKey))
      return false;
    return true;
  }
  bool operator != (const THBaseKeyRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseKeyRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseKeyRange &a, THBaseKeyRange &b);

typedef struct _TScanRange__isset {
  _TScanRange__isset() : hdfs_file_split(false), hbase_key_range(false) {}
  bool hdfs_file_split;
  bool hbase_key_range;
} _TScanRange__isset;

class TScanRange {
 public:

  static const char* ascii_fingerprint; // = "3375FEB6FC792611F5B83B498340EAA2";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x75,0xFE,0xB6,0xFC,0x79,0x26,0x11,0xF5,0xB8,0x3B,0x49,0x83,0x40,0xEA,0xA2};

  TScanRange() {
  }

  virtual ~TScanRange() throw() {}

  THdfsFileSplit hdfs_file_split;
  THBaseKeyRange hbase_key_range;

  _TScanRange__isset __isset;

  void __set_hdfs_file_split(const THdfsFileSplit& val) {
    hdfs_file_split = val;
    __isset.hdfs_file_split = true;
  }

  void __set_hbase_key_range(const THBaseKeyRange& val) {
    hbase_key_range = val;
    __isset.hbase_key_range = true;
  }

  bool operator == (const TScanRange & rhs) const
  {
    if (__isset.hdfs_file_split != rhs.__isset.hdfs_file_split)
      return false;
    else if (__isset.hdfs_file_split && !(hdfs_file_split == rhs.hdfs_file_split))
      return false;
    if (__isset.hbase_key_range != rhs.__isset.hbase_key_range)
      return false;
    else if (__isset.hbase_key_range && !(hbase_key_range == rhs.hbase_key_range))
      return false;
    return true;
  }
  bool operator != (const TScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRange &a, TScanRange &b);


class THdfsScanNode {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  THdfsScanNode() : tuple_id(0) {
  }

  virtual ~THdfsScanNode() throw() {}

   ::impala::TTupleId tuple_id;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  bool operator == (const THdfsScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const THdfsScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsScanNode &a, THdfsScanNode &b);


class THBaseFilter {
 public:

  static const char* ascii_fingerprint; // = "AC16F1200213405F9A9267FCBF95F39A";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0x16,0xF1,0x20,0x02,0x13,0x40,0x5F,0x9A,0x92,0x67,0xFC,0xBF,0x95,0xF3,0x9A};

  THBaseFilter() : family(), qualifier(), op_ordinal(0), filter_constant() {
  }

  virtual ~THBaseFilter() throw() {}

  std::string family;
  std::string qualifier;
  int32_t op_ordinal;
  std::string filter_constant;

  void __set_family(const std::string& val) {
    family = val;
  }

  void __set_qualifier(const std::string& val) {
    qualifier = val;
  }

  void __set_op_ordinal(const int32_t val) {
    op_ordinal = val;
  }

  void __set_filter_constant(const std::string& val) {
    filter_constant = val;
  }

  bool operator == (const THBaseFilter & rhs) const
  {
    if (!(family == rhs.family))
      return false;
    if (!(qualifier == rhs.qualifier))
      return false;
    if (!(op_ordinal == rhs.op_ordinal))
      return false;
    if (!(filter_constant == rhs.filter_constant))
      return false;
    return true;
  }
  bool operator != (const THBaseFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseFilter &a, THBaseFilter &b);

typedef struct _THBaseScanNode__isset {
  _THBaseScanNode__isset() : filters(false) {}
  bool filters;
} _THBaseScanNode__isset;

class THBaseScanNode {
 public:

  static const char* ascii_fingerprint; // = "98D0FFE72423C9A6FE4369BC7E6BE5E8";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0xD0,0xFF,0xE7,0x24,0x23,0xC9,0xA6,0xFE,0x43,0x69,0xBC,0x7E,0x6B,0xE5,0xE8};

  THBaseScanNode() : tuple_id(0), table_name() {
  }

  virtual ~THBaseScanNode() throw() {}

   ::impala::TTupleId tuple_id;
  std::string table_name;
  std::vector<THBaseFilter>  filters;

  _THBaseScanNode__isset __isset;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_filters(const std::vector<THBaseFilter> & val) {
    filters = val;
    __isset.filters = true;
  }

  bool operator == (const THBaseScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.filters != rhs.__isset.filters)
      return false;
    else if (__isset.filters && !(filters == rhs.filters))
      return false;
    return true;
  }
  bool operator != (const THBaseScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseScanNode &a, THBaseScanNode &b);


class TEqJoinCondition {
 public:

  static const char* ascii_fingerprint; // = "CD533BBF3EEC17C7873771BAD707F4EA";
  static const uint8_t binary_fingerprint[16]; // = {0xCD,0x53,0x3B,0xBF,0x3E,0xEC,0x17,0xC7,0x87,0x37,0x71,0xBA,0xD7,0x07,0xF4,0xEA};

  TEqJoinCondition() {
  }

  virtual ~TEqJoinCondition() throw() {}

   ::impala::TExpr left;
   ::impala::TExpr right;

  void __set_left(const  ::impala::TExpr& val) {
    left = val;
  }

  void __set_right(const  ::impala::TExpr& val) {
    right = val;
  }

  bool operator == (const TEqJoinCondition & rhs) const
  {
    if (!(left == rhs.left))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const TEqJoinCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEqJoinCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TEqJoinCondition &a, TEqJoinCondition &b);

typedef struct _THashJoinNode__isset {
  _THashJoinNode__isset() : other_join_conjuncts(false) {}
  bool other_join_conjuncts;
} _THashJoinNode__isset;

class THashJoinNode {
 public:

  static const char* ascii_fingerprint; // = "EB56449A44F659DFDED99DDC19014B7D";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x56,0x44,0x9A,0x44,0xF6,0x59,0xDF,0xDE,0xD9,0x9D,0xDC,0x19,0x01,0x4B,0x7D};

  THashJoinNode() : join_op((TJoinOp::type)0) {
  }

  virtual ~THashJoinNode() throw() {}

  TJoinOp::type join_op;
  std::vector<TEqJoinCondition>  eq_join_conjuncts;
  std::vector< ::impala::TExpr>  other_join_conjuncts;

  _THashJoinNode__isset __isset;

  void __set_join_op(const TJoinOp::type val) {
    join_op = val;
  }

  void __set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val) {
    eq_join_conjuncts = val;
  }

  void __set_other_join_conjuncts(const std::vector< ::impala::TExpr> & val) {
    other_join_conjuncts = val;
    __isset.other_join_conjuncts = true;
  }

  bool operator == (const THashJoinNode & rhs) const
  {
    if (!(join_op == rhs.join_op))
      return false;
    if (!(eq_join_conjuncts == rhs.eq_join_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    return true;
  }
  bool operator != (const THashJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THashJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THashJoinNode &a, THashJoinNode &b);

typedef struct _TAggregationNode__isset {
  _TAggregationNode__isset() : grouping_exprs(false) {}
  bool grouping_exprs;
} _TAggregationNode__isset;

class TAggregationNode {
 public:

  static const char* ascii_fingerprint; // = "0B0DB5CE2212FEEA509FD27E4D4E644B";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0x0D,0xB5,0xCE,0x22,0x12,0xFE,0xEA,0x50,0x9F,0xD2,0x7E,0x4D,0x4E,0x64,0x4B};

  TAggregationNode() : agg_tuple_id(0), need_finalize(0) {
  }

  virtual ~TAggregationNode() throw() {}

  std::vector< ::impala::TExpr>  grouping_exprs;
  std::vector< ::impala::TExpr>  aggregate_exprs;
   ::impala::TTupleId agg_tuple_id;
  bool need_finalize;

  _TAggregationNode__isset __isset;

  void __set_grouping_exprs(const std::vector< ::impala::TExpr> & val) {
    grouping_exprs = val;
    __isset.grouping_exprs = true;
  }

  void __set_aggregate_exprs(const std::vector< ::impala::TExpr> & val) {
    aggregate_exprs = val;
  }

  void __set_agg_tuple_id(const  ::impala::TTupleId val) {
    agg_tuple_id = val;
  }

  void __set_need_finalize(const bool val) {
    need_finalize = val;
  }

  bool operator == (const TAggregationNode & rhs) const
  {
    if (__isset.grouping_exprs != rhs.__isset.grouping_exprs)
      return false;
    else if (__isset.grouping_exprs && !(grouping_exprs == rhs.grouping_exprs))
      return false;
    if (!(aggregate_exprs == rhs.aggregate_exprs))
      return false;
    if (!(agg_tuple_id == rhs.agg_tuple_id))
      return false;
    if (!(need_finalize == rhs.need_finalize))
      return false;
    return true;
  }
  bool operator != (const TAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregationNode &a, TAggregationNode &b);


class TSortNode {
 public:

  static const char* ascii_fingerprint; // = "EF6D81A0F991D37567BCC21A03A3FD9E";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0x6D,0x81,0xA0,0xF9,0x91,0xD3,0x75,0x67,0xBC,0xC2,0x1A,0x03,0xA3,0xFD,0x9E};

  TSortNode() : use_top_n(0), is_default_limit(0) {
  }

  virtual ~TSortNode() throw() {}

  std::vector< ::impala::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  bool use_top_n;
  bool is_default_limit;

  void __set_ordering_exprs(const std::vector< ::impala::TExpr> & val) {
    ordering_exprs = val;
  }

  void __set_is_asc_order(const std::vector<bool> & val) {
    is_asc_order = val;
  }

  void __set_use_top_n(const bool val) {
    use_top_n = val;
  }

  void __set_is_default_limit(const bool val) {
    is_default_limit = val;
  }

  bool operator == (const TSortNode & rhs) const
  {
    if (!(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (!(is_asc_order == rhs.is_asc_order))
      return false;
    if (!(use_top_n == rhs.use_top_n))
      return false;
    if (!(is_default_limit == rhs.is_default_limit))
      return false;
    return true;
  }
  bool operator != (const TSortNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSortNode &a, TSortNode &b);


class TMergeNode {
 public:

  static const char* ascii_fingerprint; // = "8E1DC5B8DF21B2E0BE4333A4EC5BC79D";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0x1D,0xC5,0xB8,0xDF,0x21,0xB2,0xE0,0xBE,0x43,0x33,0xA4,0xEC,0x5B,0xC7,0x9D};

  TMergeNode() : tuple_id(0) {
  }

  virtual ~TMergeNode() throw() {}

   ::impala::TTupleId tuple_id;
  std::vector<std::vector< ::impala::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::impala::TExpr> >  const_expr_lists;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  void __set_result_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
    result_expr_lists = val;
  }

  void __set_const_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
    const_expr_lists = val;
  }

  bool operator == (const TMergeNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    return true;
  }
  bool operator != (const TMergeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMergeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMergeNode &a, TMergeNode &b);


class TExchangeNode {
 public:

  static const char* ascii_fingerprint; // = "A803C54EAD95E24D90C5E66FB98EA72B";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

  TExchangeNode() {
  }

  virtual ~TExchangeNode() throw() {}

  std::vector< ::impala::TTupleId>  input_row_tuples;

  void __set_input_row_tuples(const std::vector< ::impala::TTupleId> & val) {
    input_row_tuples = val;
  }

  bool operator == (const TExchangeNode & rhs) const
  {
    if (!(input_row_tuples == rhs.input_row_tuples))
      return false;
    return true;
  }
  bool operator != (const TExchangeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExchangeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExchangeNode &a, TExchangeNode &b);

typedef struct _TPlanNode__isset {
  _TPlanNode__isset() : conjuncts(false), hdfs_scan_node(false), hbase_scan_node(false), hash_join_node(false), agg_node(false), sort_node(false), merge_node(false), exchange_node(false) {}
  bool conjuncts;
  bool hdfs_scan_node;
  bool hbase_scan_node;
  bool hash_join_node;
  bool agg_node;
  bool sort_node;
  bool merge_node;
  bool exchange_node;
} _TPlanNode__isset;

class TPlanNode {
 public:

  static const char* ascii_fingerprint; // = "9D0AA257F0B26E3819E7A5646EC10909";
  static const uint8_t binary_fingerprint[16]; // = {0x9D,0x0A,0xA2,0x57,0xF0,0xB2,0x6E,0x38,0x19,0xE7,0xA5,0x64,0x6E,0xC1,0x09,0x09};

  TPlanNode() : node_id(0), node_type((TPlanNodeType::type)0), num_children(0), limit(0), compact_data(0) {
  }

  virtual ~TPlanNode() throw() {}

   ::impala::TPlanNodeId node_id;
  TPlanNodeType::type node_type;
  int32_t num_children;
  int64_t limit;
  std::vector< ::impala::TTupleId>  row_tuples;
  std::vector<bool>  nullable_tuples;
  std::vector< ::impala::TExpr>  conjuncts;
  bool compact_data;
  THdfsScanNode hdfs_scan_node;
  THBaseScanNode hbase_scan_node;
  THashJoinNode hash_join_node;
  TAggregationNode agg_node;
  TSortNode sort_node;
  TMergeNode merge_node;
  TExchangeNode exchange_node;

  _TPlanNode__isset __isset;

  void __set_node_id(const  ::impala::TPlanNodeId val) {
    node_id = val;
  }

  void __set_node_type(const TPlanNodeType::type val) {
    node_type = val;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_limit(const int64_t val) {
    limit = val;
  }

  void __set_row_tuples(const std::vector< ::impala::TTupleId> & val) {
    row_tuples = val;
  }

  void __set_nullable_tuples(const std::vector<bool> & val) {
    nullable_tuples = val;
  }

  void __set_conjuncts(const std::vector< ::impala::TExpr> & val) {
    conjuncts = val;
    __isset.conjuncts = true;
  }

  void __set_compact_data(const bool val) {
    compact_data = val;
  }

  void __set_hdfs_scan_node(const THdfsScanNode& val) {
    hdfs_scan_node = val;
    __isset.hdfs_scan_node = true;
  }

  void __set_hbase_scan_node(const THBaseScanNode& val) {
    hbase_scan_node = val;
    __isset.hbase_scan_node = true;
  }

  void __set_hash_join_node(const THashJoinNode& val) {
    hash_join_node = val;
    __isset.hash_join_node = true;
  }

  void __set_agg_node(const TAggregationNode& val) {
    agg_node = val;
    __isset.agg_node = true;
  }

  void __set_sort_node(const TSortNode& val) {
    sort_node = val;
    __isset.sort_node = true;
  }

  void __set_merge_node(const TMergeNode& val) {
    merge_node = val;
    __isset.merge_node = true;
  }

  void __set_exchange_node(const TExchangeNode& val) {
    exchange_node = val;
    __isset.exchange_node = true;
  }

  bool operator == (const TPlanNode & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(node_type == rhs.node_type))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(row_tuples == rhs.row_tuples))
      return false;
    if (!(nullable_tuples == rhs.nullable_tuples))
      return false;
    if (__isset.conjuncts != rhs.__isset.conjuncts)
      return false;
    else if (__isset.conjuncts && !(conjuncts == rhs.conjuncts))
      return false;
    if (!(compact_data == rhs.compact_data))
      return false;
    if (__isset.hdfs_scan_node != rhs.__isset.hdfs_scan_node)
      return false;
    else if (__isset.hdfs_scan_node && !(hdfs_scan_node == rhs.hdfs_scan_node))
      return false;
    if (__isset.hbase_scan_node != rhs.__isset.hbase_scan_node)
      return false;
    else if (__isset.hbase_scan_node && !(hbase_scan_node == rhs.hbase_scan_node))
      return false;
    if (__isset.hash_join_node != rhs.__isset.hash_join_node)
      return false;
    else if (__isset.hash_join_node && !(hash_join_node == rhs.hash_join_node))
      return false;
    if (__isset.agg_node != rhs.__isset.agg_node)
      return false;
    else if (__isset.agg_node && !(agg_node == rhs.agg_node))
      return false;
    if (__isset.sort_node != rhs.__isset.sort_node)
      return false;
    else if (__isset.sort_node && !(sort_node == rhs.sort_node))
      return false;
    if (__isset.merge_node != rhs.__isset.merge_node)
      return false;
    else if (__isset.merge_node && !(merge_node == rhs.merge_node))
      return false;
    if (__isset.exchange_node != rhs.__isset.exchange_node)
      return false;
    else if (__isset.exchange_node && !(exchange_node == rhs.exchange_node))
      return false;
    return true;
  }
  bool operator != (const TPlanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanNode &a, TPlanNode &b);


class TPlan {
 public:

  static const char* ascii_fingerprint; // = "371CA622539C2D47699AB0E525454D36";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x1C,0xA6,0x22,0x53,0x9C,0x2D,0x47,0x69,0x9A,0xB0,0xE5,0x25,0x45,0x4D,0x36};

  TPlan() {
  }

  virtual ~TPlan() throw() {}

  std::vector<TPlanNode>  nodes;

  void __set_nodes(const std::vector<TPlanNode> & val) {
    nodes = val;
  }

  bool operator == (const TPlan & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TPlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlan &a, TPlan &b);

} // namespace

#endif
