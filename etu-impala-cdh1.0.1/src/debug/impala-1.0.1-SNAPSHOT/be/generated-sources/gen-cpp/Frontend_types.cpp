/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Frontend_types.h"

#include <algorithm>

namespace impala {

int _kTFileFormatValues[] = {
  TFileFormat::PARQUETFILE,
  TFileFormat::RCFILE,
  TFileFormat::SEQUENCEFILE,
  TFileFormat::TEXTFILE
};
const char* _kTFileFormatNames[] = {
  "PARQUETFILE",
  "RCFILE",
  "SEQUENCEFILE",
  "TEXTFILE"
};
const std::map<int, const char*> _TFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFileFormatValues, _kTFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAlterTableTypeValues[] = {
  TAlterTableType::ADD_REPLACE_COLUMNS,
  TAlterTableType::ADD_PARTITION,
  TAlterTableType::CHANGE_COLUMN,
  TAlterTableType::DROP_COLUMN,
  TAlterTableType::DROP_PARTITION,
  TAlterTableType::RENAME_TABLE,
  TAlterTableType::SET_FILE_FORMAT,
  TAlterTableType::SET_LOCATION
};
const char* _kTAlterTableTypeNames[] = {
  "ADD_REPLACE_COLUMNS",
  "ADD_PARTITION",
  "CHANGE_COLUMN",
  "DROP_COLUMN",
  "DROP_PARTITION",
  "RENAME_TABLE",
  "SET_FILE_FORMAT",
  "SET_LOCATION"
};
const std::map<int, const char*> _TAlterTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTAlterTableTypeValues, _kTAlterTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDdlTypeValues[] = {
  TDdlType::SHOW_TABLES,
  TDdlType::SHOW_DBS,
  TDdlType::USE,
  TDdlType::DESCRIBE,
  TDdlType::ALTER_TABLE,
  TDdlType::CREATE_DATABASE,
  TDdlType::CREATE_TABLE,
  TDdlType::CREATE_TABLE_LIKE,
  TDdlType::DROP_DATABASE,
  TDdlType::DROP_TABLE
};
const char* _kTDdlTypeNames[] = {
  "SHOW_TABLES",
  "SHOW_DBS",
  "USE",
  "DESCRIBE",
  "ALTER_TABLE",
  "CREATE_DATABASE",
  "CREATE_TABLE",
  "CREATE_TABLE_LIKE",
  "DROP_DATABASE",
  "DROP_TABLE"
};
const std::map<int, const char*> _TDdlType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTDdlTypeValues, _kTDdlTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTMetadataOpcodeValues[] = {
  TMetadataOpcode::GET_TYPE_INFO,
  TMetadataOpcode::GET_CATALOGS,
  TMetadataOpcode::GET_SCHEMAS,
  TMetadataOpcode::GET_TABLES,
  TMetadataOpcode::GET_TABLE_TYPES,
  TMetadataOpcode::GET_COLUMNS,
  TMetadataOpcode::GET_FUNCTIONS
};
const char* _kTMetadataOpcodeNames[] = {
  "GET_TYPE_INFO",
  "GET_CATALOGS",
  "GET_SCHEMAS",
  "GET_TABLES",
  "GET_TABLE_TYPES",
  "GET_COLUMNS",
  "GET_FUNCTIONS"
};
const std::map<int, const char*> _TMetadataOpcode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTMetadataOpcodeValues, _kTMetadataOpcodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TGetTablesParams::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t TGetTablesParams::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t TGetTablesParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetTablesParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TGetTablesParams");

  if (this->__isset.db) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pattern) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesParams &a, TGetTablesParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.pattern, b.pattern);
  swap(a.__isset, b.__isset);
}

const char* TGetTablesResult::ascii_fingerprint = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
const uint8_t TGetTablesResult::binary_fingerprint[16] = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

uint32_t TGetTablesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->tables.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->tables[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetTablesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TGetTablesResult");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->tables.begin(); _iter5 != this->tables.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetTablesResult &a, TGetTablesResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
  swap(a.__isset, b.__isset);
}

const char* TGetDbsParams::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TGetDbsParams::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TGetDbsParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetDbsParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TGetDbsParams");

  if (this->__isset.pattern) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDbsParams &a, TGetDbsParams &b) {
  using ::std::swap;
  swap(a.pattern, b.pattern);
  swap(a.__isset, b.__isset);
}

const char* TGetDbsResult::ascii_fingerprint = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
const uint8_t TGetDbsResult::binary_fingerprint[16] = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

uint32_t TGetDbsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dbs.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->dbs.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->dbs[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGetDbsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TGetDbsResult");

  ++fcnt;
  xfer += oprot->writeFieldBegin("dbs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dbs.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->dbs.begin(); _iter11 != this->dbs.end(); ++_iter11)
    {
      xfer += oprot->writeString((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGetDbsResult &a, TGetDbsResult &b) {
  using ::std::swap;
  swap(a.dbs, b.dbs);
  swap(a.__isset, b.__isset);
}

const char* TColumnDesc::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t TColumnDesc::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t TColumnDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_columnType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->columnType = ( ::impala::TPrimitiveType::type)ecast12;
          isset_columnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TColumnDesc");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->columnType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.columnType, b.columnType);
}

const char* TColumnDef::ascii_fingerprint = "1A466928A838FDE756589DF00F1277D0";
const uint8_t TColumnDef::binary_fingerprint[16] = {0x1A,0x46,0x69,0x28,0xA8,0x38,0xFD,0xE7,0x56,0x58,0x9D,0xF0,0x0F,0x12,0x77,0xD0};

uint32_t TColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnDesc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->columnDesc.read(iprot);
          isset_columnDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TColumnDef");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->columnDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnDef &a, TColumnDef &b) {
  using ::std::swap;
  swap(a.columnDesc, b.columnDesc);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

const char* TDescribeTableParams::ascii_fingerprint = "383E55F0D02199A3E52B9227E13A83A2";
const uint8_t TDescribeTableParams::binary_fingerprint[16] = {0x38,0x3E,0x55,0xF0,0xD0,0x21,0x99,0xA3,0xE5,0x2B,0x92,0x27,0xE1,0x3A,0x83,0xA2};

uint32_t TDescribeTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescribeTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDescribeTableParams");

  if (this->__isset.db) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescribeTableParams &a, TDescribeTableParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.table_name, b.table_name);
  swap(a.__isset, b.__isset);
}

const char* TDescribeTableResult::ascii_fingerprint = "310594E5EEC07991F491FF2D8123E958";
const uint8_t TDescribeTableResult::binary_fingerprint[16] = {0x31,0x05,0x94,0xE5,0xEE,0xC0,0x79,0x91,0xF4,0x91,0xFF,0x2D,0x81,0x23,0xE9,0x58};

uint32_t TDescribeTableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->columns.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->columns[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDescribeTableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDescribeTableResult");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDef> ::const_iterator _iter18;
    for (_iter18 = this->columns.begin(); _iter18 != this->columns.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDescribeTableResult &a, TDescribeTableResult &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
}

const char* TCreateDbParams::ascii_fingerprint = "CAD4F97378DF2EFF77F23A193511C552";
const uint8_t TCreateDbParams::binary_fingerprint[16] = {0xCA,0xD4,0xF9,0x73,0x78,0xDF,0x2E,0xFF,0x77,0xF2,0x3A,0x19,0x35,0x11,0xC5,0x52};

uint32_t TCreateDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCreateDbParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.if_not_exists) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateDbParams &a, TCreateDbParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.comment, b.comment);
  swap(a.location, b.location);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.__isset, b.__isset);
}

const char* TTableName::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TTableName::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TTableName::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTableName");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
}

const char* TTableRowFormat::ascii_fingerprint = "B2C950B9C25B62CA02C2A8C700FEE26F";
const uint8_t TTableRowFormat::binary_fingerprint[16] = {0xB2,0xC9,0x50,0xB9,0xC2,0x5B,0x62,0xCA,0x02,0xC2,0xA8,0xC7,0x00,0xFE,0xE2,0x6F};

uint32_t TTableRowFormat::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_terminator);
          this->__isset.field_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_terminator);
          this->__isset.line_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escaped_by);
          this->__isset.escaped_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableRowFormat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTableRowFormat");

  if (this->__isset.field_terminator) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("field_terminator", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->field_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_terminator) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("line_terminator", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->line_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.escaped_by) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("escaped_by", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->escaped_by);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableRowFormat &a, TTableRowFormat &b) {
  using ::std::swap;
  swap(a.field_terminator, b.field_terminator);
  swap(a.line_terminator, b.line_terminator);
  swap(a.escaped_by, b.escaped_by);
  swap(a.__isset, b.__isset);
}

const char* TPartitionKeyValue::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TPartitionKeyValue::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TPartitionKeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPartitionKeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TPartitionKeyValue");

  ++fcnt;
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

const char* TAlterTableRenameParams::ascii_fingerprint = "A756D3DBE614FB13F70BF7F7B6EB3D73";
const uint8_t TAlterTableRenameParams::binary_fingerprint[16] = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

uint32_t TAlterTableRenameParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_new_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_table_name.read(iprot);
          isset_new_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_new_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableRenameParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableRenameParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("new_table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->new_table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableRenameParams &a, TAlterTableRenameParams &b) {
  using ::std::swap;
  swap(a.new_table_name, b.new_table_name);
}

const char* TAlterTableAddReplaceColsParams::ascii_fingerprint = "8A062F846D2647E1DF73D40439FB8C26";
const uint8_t TAlterTableAddReplaceColsParams::binary_fingerprint[16] = {0x8A,0x06,0x2F,0x84,0x6D,0x26,0x47,0xE1,0xDF,0x73,0xD4,0x04,0x39,0xFB,0x8C,0x26};

uint32_t TAlterTableAddReplaceColsParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_replace_existing_cols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->columns.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->columns[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replace_existing_cols);
          isset_replace_existing_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_replace_existing_cols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableAddReplaceColsParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableAddReplaceColsParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDef> ::const_iterator _iter24;
    for (_iter24 = this->columns.begin(); _iter24 != this->columns.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("replace_existing_cols", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->replace_existing_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableAddReplaceColsParams &a, TAlterTableAddReplaceColsParams &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.replace_existing_cols, b.replace_existing_cols);
}

const char* TAlterTableAddPartitionParams::ascii_fingerprint = "DDBF94C5C0804BF720FBDF685968F8B2";
const uint8_t TAlterTableAddPartitionParams::binary_fingerprint[16] = {0xDD,0xBF,0x94,0xC5,0xC0,0x80,0x4B,0xF7,0x20,0xFB,0xDF,0x68,0x59,0x68,0xF8,0xB2};

uint32_t TAlterTableAddPartitionParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_spec = false;
  bool isset_if_not_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->partition_spec.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->partition_spec[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableAddPartitionParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableAddPartitionParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
    std::vector<TPartitionKeyValue> ::const_iterator _iter30;
    for (_iter30 = this->partition_spec.begin(); _iter30 != this->partition_spec.end(); ++_iter30)
    {
      xfer += (*_iter30).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableAddPartitionParams &a, TAlterTableAddPartitionParams &b) {
  using ::std::swap;
  swap(a.partition_spec, b.partition_spec);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.location, b.location);
  swap(a.__isset, b.__isset);
}

const char* TAlterTableDropColParams::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TAlterTableDropColParams::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TAlterTableDropColParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_col_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          isset_col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_col_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableDropColParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableDropColParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableDropColParams &a, TAlterTableDropColParams &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
}

const char* TAlterTableDropPartitionParams::ascii_fingerprint = "6F92A0A7B206615BE32209BF2E6A7ED1";
const uint8_t TAlterTableDropPartitionParams::binary_fingerprint[16] = {0x6F,0x92,0xA0,0xA7,0xB2,0x06,0x61,0x5B,0xE3,0x22,0x09,0xBF,0x2E,0x6A,0x7E,0xD1};

uint32_t TAlterTableDropPartitionParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_spec = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->partition_spec.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->partition_spec[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableDropPartitionParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableDropPartitionParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
    std::vector<TPartitionKeyValue> ::const_iterator _iter36;
    for (_iter36 = this->partition_spec.begin(); _iter36 != this->partition_spec.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableDropPartitionParams &a, TAlterTableDropPartitionParams &b) {
  using ::std::swap;
  swap(a.partition_spec, b.partition_spec);
  swap(a.if_exists, b.if_exists);
}

const char* TAlterTableChangeColParams::ascii_fingerprint = "50D38FCE9C274638E6D49F7975E2CE6C";
const uint8_t TAlterTableChangeColParams::binary_fingerprint[16] = {0x50,0xD3,0x8F,0xCE,0x9C,0x27,0x46,0x38,0xE6,0xD4,0x9F,0x79,0x75,0xE2,0xCE,0x6C};

uint32_t TAlterTableChangeColParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_col_name = false;
  bool isset_new_col_def = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          isset_col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_col_def.read(iprot);
          isset_new_col_def = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_col_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_new_col_def)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableChangeColParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableChangeColParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("new_col_def", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->new_col_def.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableChangeColParams &a, TAlterTableChangeColParams &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.new_col_def, b.new_col_def);
}

const char* TAlterTableSetFileFormatParams::ascii_fingerprint = "101E22EEE714785E462FCF6056B14937";
const uint8_t TAlterTableSetFileFormatParams::binary_fingerprint[16] = {0x10,0x1E,0x22,0xEE,0xE7,0x14,0x78,0x5E,0x46,0x2F,0xCF,0x60,0x56,0xB1,0x49,0x37};

uint32_t TAlterTableSetFileFormatParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_format = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->file_format = (TFileFormat::type)ecast37;
          isset_file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->partition_spec.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->partition_spec[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableSetFileFormatParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableSetFileFormatParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->file_format);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_spec) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
      std::vector<TPartitionKeyValue> ::const_iterator _iter43;
      for (_iter43 = this->partition_spec.begin(); _iter43 != this->partition_spec.end(); ++_iter43)
      {
        xfer += (*_iter43).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableSetFileFormatParams &a, TAlterTableSetFileFormatParams &b) {
  using ::std::swap;
  swap(a.file_format, b.file_format);
  swap(a.partition_spec, b.partition_spec);
  swap(a.__isset, b.__isset);
}

const char* TAlterTableSetLocationParams::ascii_fingerprint = "620BD7B2710FAEABD876BE1FA48F69F0";
const uint8_t TAlterTableSetLocationParams::binary_fingerprint[16] = {0x62,0x0B,0xD7,0xB2,0x71,0x0F,0xAE,0xAB,0xD8,0x76,0xBE,0x1F,0xA4,0x8F,0x69,0xF0};

uint32_t TAlterTableSetLocationParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->partition_spec.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += this->partition_spec[_i48].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableSetLocationParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableSetLocationParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_spec) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
      std::vector<TPartitionKeyValue> ::const_iterator _iter49;
      for (_iter49 = this->partition_spec.begin(); _iter49 != this->partition_spec.end(); ++_iter49)
      {
        xfer += (*_iter49).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableSetLocationParams &a, TAlterTableSetLocationParams &b) {
  using ::std::swap;
  swap(a.location, b.location);
  swap(a.partition_spec, b.partition_spec);
  swap(a.__isset, b.__isset);
}

const char* TAlterTableParams::ascii_fingerprint = "8F534EA99B58367B90C40A9C386F9A64";
const uint8_t TAlterTableParams::binary_fingerprint[16] = {0x8F,0x53,0x4E,0xA9,0x9B,0x58,0x36,0x7B,0x90,0xC4,0x0A,0x9C,0x38,0x6F,0x9A,0x64};

uint32_t TAlterTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_alter_type = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->alter_type = (TAlterTableType::type)ecast50;
          isset_alter_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rename_params.read(iprot);
          this->__isset.rename_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->add_replace_cols_params.read(iprot);
          this->__isset.add_replace_cols_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->add_partition_params.read(iprot);
          this->__isset.add_partition_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->change_col_params.read(iprot);
          this->__isset.change_col_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_col_params.read(iprot);
          this->__isset.drop_col_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_partition_params.read(iprot);
          this->__isset.drop_partition_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_file_format_params.read(iprot);
          this->__isset.set_file_format_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_location_params.read(iprot);
          this->__isset.set_location_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_alter_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAlterTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAlterTableParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("alter_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->alter_type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rename_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("rename_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->rename_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_replace_cols_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("add_replace_cols_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->add_replace_cols_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_partition_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("add_partition_params", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->add_partition_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.change_col_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("change_col_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->change_col_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_col_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("drop_col_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->drop_col_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_partition_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("drop_partition_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->drop_partition_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_file_format_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("set_file_format_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->set_file_format_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_location_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("set_location_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->set_location_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAlterTableParams &a, TAlterTableParams &b) {
  using ::std::swap;
  swap(a.alter_type, b.alter_type);
  swap(a.table_name, b.table_name);
  swap(a.rename_params, b.rename_params);
  swap(a.add_replace_cols_params, b.add_replace_cols_params);
  swap(a.add_partition_params, b.add_partition_params);
  swap(a.change_col_params, b.change_col_params);
  swap(a.drop_col_params, b.drop_col_params);
  swap(a.drop_partition_params, b.drop_partition_params);
  swap(a.set_file_format_params, b.set_file_format_params);
  swap(a.set_location_params, b.set_location_params);
  swap(a.__isset, b.__isset);
}

const char* TCreateTableLikeParams::ascii_fingerprint = "7BEC16F01713BB030792212D7EDE7C30";
const uint8_t TCreateTableLikeParams::binary_fingerprint[16] = {0x7B,0xEC,0x16,0xF0,0x17,0x13,0xBB,0x03,0x07,0x92,0x21,0x2D,0x7E,0xDE,0x7C,0x30};

uint32_t TCreateTableLikeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_src_table_name = false;
  bool isset_is_external = false;
  bool isset_if_not_exists = false;
  bool isset_owner = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->src_table_name.read(iprot);
          isset_src_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_external);
          isset_is_external = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->file_format = (TFileFormat::type)ecast51;
          this->__isset.file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_external)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTableLikeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCreateTableLikeParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("src_table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->src_table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_external", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_external);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_format) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->file_format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTableLikeParams &a, TCreateTableLikeParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.src_table_name, b.src_table_name);
  swap(a.is_external, b.is_external);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.owner, b.owner);
  swap(a.file_format, b.file_format);
  swap(a.comment, b.comment);
  swap(a.location, b.location);
  swap(a.__isset, b.__isset);
}

const char* TCreateTableParams::ascii_fingerprint = "A806D16923885311424912DE4D07024D";
const uint8_t TCreateTableParams::binary_fingerprint[16] = {0xA8,0x06,0xD1,0x69,0x23,0x88,0x53,0x11,0x42,0x49,0x12,0xDE,0x4D,0x07,0x02,0x4D};

uint32_t TCreateTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_columns = false;
  bool isset_file_format = false;
  bool isset_is_external = false;
  bool isset_if_not_exists = false;
  bool isset_owner = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->columns.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->columns[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_columns.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->partition_columns.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->partition_columns[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->file_format = (TFileFormat::type)ecast62;
          isset_file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_external);
          isset_is_external = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_format.read(iprot);
          this->__isset.row_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_external)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCreateTableParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnDef> ::const_iterator _iter63;
    for (_iter63 = this->columns.begin(); _iter63 != this->columns.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_columns) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("partition_columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_columns.size()));
      std::vector<TColumnDef> ::const_iterator _iter64;
      for (_iter64 = this->partition_columns.begin(); _iter64 != this->partition_columns.end(); ++_iter64)
      {
        xfer += (*_iter64).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->file_format);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_external", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_external);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.row_format) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("row_format", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->row_format.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTableParams &a, TCreateTableParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.columns, b.columns);
  swap(a.partition_columns, b.partition_columns);
  swap(a.file_format, b.file_format);
  swap(a.is_external, b.is_external);
  swap(a.if_not_exists, b.if_not_exists);
  swap(a.owner, b.owner);
  swap(a.row_format, b.row_format);
  swap(a.comment, b.comment);
  swap(a.location, b.location);
  swap(a.__isset, b.__isset);
}

const char* TDropDbParams::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t TDropDbParams::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t TDropDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDropDbParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropDbParams &a, TDropDbParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.if_exists, b.if_exists);
}

const char* TDropTableParams::ascii_fingerprint = "790158CF902C527D004C99E60A2E4B2E";
const uint8_t TDropTableParams::binary_fingerprint[16] = {0x79,0x01,0x58,0xCF,0x90,0x2C,0x52,0x7D,0x00,0x4C,0x99,0xE6,0x0A,0x2E,0x4B,0x2E};

uint32_t TDropTableParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDropTableParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDropTableParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDropTableParams &a, TDropTableParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.if_exists, b.if_exists);
}

const char* TSessionState::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t TSessionState::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t TSessionState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database = false;
  bool isset_user = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSessionState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TSessionState");

  ++fcnt;
  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionState &a, TSessionState &b) {
  using ::std::swap;
  swap(a.database, b.database);
  swap(a.user, b.user);
}

const char* TClientRequest::ascii_fingerprint = "AEEBB37EB85D30D8B07D47726C1C3058";
const uint8_t TClientRequest::binary_fingerprint[16] = {0xAE,0xEB,0xB3,0x7E,0xB8,0x5D,0x30,0xD8,0xB0,0x7D,0x47,0x72,0x6C,0x1C,0x30,0x58};

uint32_t TClientRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stmt = false;
  bool isset_queryOptions = false;
  bool isset_sessionState = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stmt);
          isset_stmt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryOptions.read(iprot);
          isset_queryOptions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sessionState.read(iprot);
          isset_sessionState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stmt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryOptions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sessionState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TClientRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TClientRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("stmt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->stmt);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("queryOptions", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->queryOptions.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("sessionState", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sessionState.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClientRequest &a, TClientRequest &b) {
  using ::std::swap;
  swap(a.stmt, b.stmt);
  swap(a.queryOptions, b.queryOptions);
  swap(a.sessionState, b.sessionState);
}

const char* TShowDbsParams::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t TShowDbsParams::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t TShowDbsParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TShowDbsParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TShowDbsParams");

  if (this->__isset.show_pattern) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowDbsParams &a, TShowDbsParams &b) {
  using ::std::swap;
  swap(a.show_pattern, b.show_pattern);
  swap(a.__isset, b.__isset);
}

const char* TShowTablesParams::ascii_fingerprint = "D0297FC5011701BD87898CC36146A565";
const uint8_t TShowTablesParams::binary_fingerprint[16] = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

uint32_t TShowTablesParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TShowTablesParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TShowTablesParams");

  if (this->__isset.db) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_pattern) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowTablesParams &a, TShowTablesParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
  swap(a.show_pattern, b.show_pattern);
  swap(a.__isset, b.__isset);
}

const char* TUseDbParams::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TUseDbParams::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TUseDbParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TUseDbParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TUseDbParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUseDbParams &a, TUseDbParams &b) {
  using ::std::swap;
  swap(a.db, b.db);
}

const char* TExplainResult::ascii_fingerprint = "33B1AC796556B5D176326D0D2FCA5450";
const uint8_t TExplainResult::binary_fingerprint[16] = {0x33,0xB1,0xAC,0x79,0x65,0x56,0xB5,0xD1,0x76,0x32,0x6D,0x0D,0x2F,0xCA,0x54,0x50};

uint32_t TExplainResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->results.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->results[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExplainResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExplainResult");

  ++fcnt;
  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector< ::impala::TResultRow> ::const_iterator _iter70;
    for (_iter70 = this->results.begin(); _iter70 != this->results.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExplainResult &a, TExplainResult &b) {
  using ::std::swap;
  swap(a.results, b.results);
}

const char* TResultSetMetadata::ascii_fingerprint = "D50C2F9EC7D3B85649634752C0F64DC3";
const uint8_t TResultSetMetadata::binary_fingerprint[16] = {0xD5,0x0C,0x2F,0x9E,0xC7,0xD3,0xB8,0x56,0x49,0x63,0x47,0x52,0xC0,0xF6,0x4D,0xC3};

uint32_t TResultSetMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnDescs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnDescs.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->columnDescs.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->columnDescs[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnDescs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnDescs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResultSetMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TResultSetMetadata");

  ++fcnt;
  xfer += oprot->writeFieldBegin("columnDescs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnDescs.size()));
    std::vector<TColumnDesc> ::const_iterator _iter76;
    for (_iter76 = this->columnDescs.begin(); _iter76 != this->columnDescs.end(); ++_iter76)
    {
      xfer += (*_iter76).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResultSetMetadata &a, TResultSetMetadata &b) {
  using ::std::swap;
  swap(a.columnDescs, b.columnDescs);
}

const char* TCatalogUpdate::ascii_fingerprint = "845BD8C082A6EDFE58B66C91C7C24C6E";
const uint8_t TCatalogUpdate::binary_fingerprint[16] = {0x84,0x5B,0xD8,0xC0,0x82,0xA6,0xED,0xFE,0x58,0xB6,0x6C,0x91,0xC7,0xC2,0x4C,0x6E};

uint32_t TCatalogUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_target_table = false;
  bool isset_db_name = false;
  bool isset_created_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_table);
          isset_target_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->created_partitions.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readSetBegin(_etype80, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              std::string _elem82;
              xfer += iprot->readString(_elem82);
              this->created_partitions.insert(_elem82);
            }
            xfer += iprot->readSetEnd();
          }
          isset_created_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_target_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_created_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCatalogUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCatalogUpdate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("target_table", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->target_table);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("created_partitions", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->created_partitions.size()));
    std::set<std::string> ::const_iterator _iter83;
    for (_iter83 = this->created_partitions.begin(); _iter83 != this->created_partitions.end(); ++_iter83)
    {
      xfer += oprot->writeString((*_iter83));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCatalogUpdate &a, TCatalogUpdate &b) {
  using ::std::swap;
  swap(a.target_table, b.target_table);
  swap(a.db_name, b.db_name);
  swap(a.created_partitions, b.created_partitions);
}

const char* TFinalizeParams::ascii_fingerprint = "B7080D97FBE64A05254F705FB1FADA7F";
const uint8_t TFinalizeParams::binary_fingerprint[16] = {0xB7,0x08,0x0D,0x97,0xFB,0xE6,0x4A,0x05,0x25,0x4F,0x70,0x5F,0xB1,0xFA,0xDA,0x7F};

uint32_t TFinalizeParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_overwrite = false;
  bool isset_hdfs_base_dir = false;
  bool isset_table_name = false;
  bool isset_table_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_overwrite);
          isset_is_overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_base_dir);
          isset_hdfs_base_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          isset_table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_overwrite)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hdfs_base_dir)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFinalizeParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TFinalizeParams");

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_overwrite", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_overwrite);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("hdfs_base_dir", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hdfs_base_dir);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFinalizeParams &a, TFinalizeParams &b) {
  using ::std::swap;
  swap(a.is_overwrite, b.is_overwrite);
  swap(a.hdfs_base_dir, b.hdfs_base_dir);
  swap(a.table_name, b.table_name);
  swap(a.table_db, b.table_db);
}

const char* TQueryExecRequest::ascii_fingerprint = "1D4C017A9088C19C6BE21EB79C551FB1";
const uint8_t TQueryExecRequest::binary_fingerprint[16] = {0x1D,0x4C,0x01,0x7A,0x90,0x88,0xC1,0x9C,0x6B,0xE2,0x1E,0xB7,0x9C,0x55,0x1F,0xB1};

uint32_t TQueryExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragments = false;
  bool isset_query_globals = false;
  bool isset_stmt_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desc_tbl.read(iprot);
          this->__isset.desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fragments.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->fragments.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->fragments[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_fragments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dest_fragment_idx.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->dest_fragment_idx.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readI32(this->dest_fragment_idx[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dest_fragment_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_node_scan_ranges.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _ktype95;
            ::apache::thrift::protocol::TType _vtype96;
            xfer += iprot->readMapBegin(_ktype95, _vtype96, _size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
               ::impala::TPlanNodeId _key99;
              xfer += iprot->readI32(_key99);
              std::vector< ::impala::TScanRangeLocations> & _val100 = this->per_node_scan_ranges[_key99];
              {
                _val100.clear();
                uint32_t _size101;
                ::apache::thrift::protocol::TType _etype104;
                xfer += iprot->readListBegin(_etype104, _size101);
                _val100.resize(_size101);
                uint32_t _i105;
                for (_i105 = 0; _i105 < _size101; ++_i105)
                {
                  xfer += _val100[_i105].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.per_node_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          this->__isset.result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->finalize_params.read(iprot);
          this->__isset.finalize_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_globals.read(iprot);
          isset_query_globals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query_plan);
          this->__isset.query_plan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->stmt_type = ( ::impala::TStmtType::type)ecast106;
          isset_stmt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragments)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_query_globals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stmt_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TQueryExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TQueryExecRequest");

  if (this->__isset.desc_tbl) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("desc_tbl", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->desc_tbl.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("fragments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fragments.size()));
    std::vector< ::impala::TPlanFragment> ::const_iterator _iter107;
    for (_iter107 = this->fragments.begin(); _iter107 != this->fragments.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dest_fragment_idx) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("dest_fragment_idx", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dest_fragment_idx.size()));
      std::vector<int32_t> ::const_iterator _iter108;
      for (_iter108 = this->dest_fragment_idx.begin(); _iter108 != this->dest_fragment_idx.end(); ++_iter108)
      {
        xfer += oprot->writeI32((*_iter108));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.per_node_scan_ranges) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("per_node_scan_ranges", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->per_node_scan_ranges.size()));
      std::map< ::impala::TPlanNodeId, std::vector< ::impala::TScanRangeLocations> > ::const_iterator _iter109;
      for (_iter109 = this->per_node_scan_ranges.begin(); _iter109 != this->per_node_scan_ranges.end(); ++_iter109)
      {
        xfer += oprot->writeI32(_iter109->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter109->second.size()));
          std::vector< ::impala::TScanRangeLocations> ::const_iterator _iter110;
          for (_iter110 = _iter109->second.begin(); _iter110 != _iter109->second.end(); ++_iter110)
          {
            xfer += (*_iter110).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set_metadata) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->result_set_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finalize_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("finalize_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->finalize_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("query_globals", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->query_globals.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_plan) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("query_plan", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->query_plan);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("stmt_type", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->stmt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryExecRequest &a, TQueryExecRequest &b) {
  using ::std::swap;
  swap(a.desc_tbl, b.desc_tbl);
  swap(a.fragments, b.fragments);
  swap(a.dest_fragment_idx, b.dest_fragment_idx);
  swap(a.per_node_scan_ranges, b.per_node_scan_ranges);
  swap(a.result_set_metadata, b.result_set_metadata);
  swap(a.finalize_params, b.finalize_params);
  swap(a.query_globals, b.query_globals);
  swap(a.query_plan, b.query_plan);
  swap(a.stmt_type, b.stmt_type);
  swap(a.__isset, b.__isset);
}

const char* TDdlExecRequest::ascii_fingerprint = "0CD54BC026F4A54FCCF01B6B6F3FADA6";
const uint8_t TDdlExecRequest::binary_fingerprint[16] = {0x0C,0xD5,0x4B,0xC0,0x26,0xF4,0xA5,0x4F,0xCC,0xF0,0x1B,0x6B,0x6F,0x3F,0xAD,0xA6};

uint32_t TDdlExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ddl_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast111;
          xfer += iprot->readI32(ecast111);
          this->ddl_type = (TDdlType::type)ecast111;
          isset_ddl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->use_db_params.read(iprot);
          this->__isset.use_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->describe_table_params.read(iprot);
          this->__isset.describe_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_dbs_params.read(iprot);
          this->__isset.show_dbs_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_tables_params.read(iprot);
          this->__isset.show_tables_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_table_params.read(iprot);
          this->__isset.alter_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_db_params.read(iprot);
          this->__isset.create_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_table_params.read(iprot);
          this->__isset.create_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_table_like_params.read(iprot);
          this->__isset.create_table_like_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_db_params.read(iprot);
          this->__isset.drop_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_table_params.read(iprot);
          this->__isset.drop_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ddl_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDdlExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDdlExecRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("ddl_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->ddl_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.use_db_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("use_db_params", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->use_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.describe_table_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("describe_table_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->describe_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_dbs_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("show_dbs_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->show_dbs_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_tables_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("show_tables_params", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->show_tables_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_table_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("alter_table_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->alter_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_db_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("create_db_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->create_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_table_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("create_table_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->create_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_table_like_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("create_table_like_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->create_table_like_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_db_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("drop_db_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->drop_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_table_params) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("drop_table_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->drop_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDdlExecRequest &a, TDdlExecRequest &b) {
  using ::std::swap;
  swap(a.ddl_type, b.ddl_type);
  swap(a.use_db_params, b.use_db_params);
  swap(a.describe_table_params, b.describe_table_params);
  swap(a.show_dbs_params, b.show_dbs_params);
  swap(a.show_tables_params, b.show_tables_params);
  swap(a.alter_table_params, b.alter_table_params);
  swap(a.create_db_params, b.create_db_params);
  swap(a.create_table_params, b.create_table_params);
  swap(a.create_table_like_params, b.create_table_like_params);
  swap(a.drop_db_params, b.drop_db_params);
  swap(a.drop_table_params, b.drop_table_params);
  swap(a.__isset, b.__isset);
}

const char* TMetadataOpRequest::ascii_fingerprint = "4F3B3DA03A312B25CD984C98432A660A";
const uint8_t TMetadataOpRequest::binary_fingerprint[16] = {0x4F,0x3B,0x3D,0xA0,0x3A,0x31,0x2B,0x25,0xCD,0x98,0x4C,0x98,0x43,0x2A,0x66,0x0A};

uint32_t TMetadataOpRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_opcode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast112;
          xfer += iprot->readI32(ecast112);
          this->opcode = (TMetadataOpcode::type)ecast112;
          isset_opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_info_req.read(iprot);
          this->__isset.get_info_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_type_info_req.read(iprot);
          this->__isset.get_type_info_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_catalogs_req.read(iprot);
          this->__isset.get_catalogs_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_schemas_req.read(iprot);
          this->__isset.get_schemas_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_tables_req.read(iprot);
          this->__isset.get_tables_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_table_types_req.read(iprot);
          this->__isset.get_table_types_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_columns_req.read(iprot);
          this->__isset.get_columns_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_functions_req.read(iprot);
          this->__isset.get_functions_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_opcode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMetadataOpRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TMetadataOpRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("opcode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->opcode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.get_info_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_info_req", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->get_info_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_type_info_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_type_info_req", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->get_type_info_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_catalogs_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_catalogs_req", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->get_catalogs_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_schemas_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_schemas_req", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->get_schemas_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_tables_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_tables_req", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->get_tables_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_table_types_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_table_types_req", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->get_table_types_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_columns_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_columns_req", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->get_columns_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_functions_req) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("get_functions_req", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->get_functions_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMetadataOpRequest &a, TMetadataOpRequest &b) {
  using ::std::swap;
  swap(a.opcode, b.opcode);
  swap(a.get_info_req, b.get_info_req);
  swap(a.get_type_info_req, b.get_type_info_req);
  swap(a.get_catalogs_req, b.get_catalogs_req);
  swap(a.get_schemas_req, b.get_schemas_req);
  swap(a.get_tables_req, b.get_tables_req);
  swap(a.get_table_types_req, b.get_table_types_req);
  swap(a.get_columns_req, b.get_columns_req);
  swap(a.get_functions_req, b.get_functions_req);
  swap(a.__isset, b.__isset);
}

const char* TMetadataOpResponse::ascii_fingerprint = "AA4955CB4C4B7C6D8052EE00C6221E71";
const uint8_t TMetadataOpResponse::binary_fingerprint[16] = {0xAA,0x49,0x55,0xCB,0x4C,0x4B,0x7C,0x6D,0x80,0x52,0xEE,0x00,0xC6,0x22,0x1E,0x71};

uint32_t TMetadataOpResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result_set_metadata = false;
  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          isset_result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->results.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += this->results[_i117].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result_set_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TMetadataOpResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TMetadataOpResponse");

  ++fcnt;
  xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result_set_metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector< ::impala::TResultRow> ::const_iterator _iter118;
    for (_iter118 = this->results.begin(); _iter118 != this->results.end(); ++_iter118)
    {
      xfer += (*_iter118).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMetadataOpResponse &a, TMetadataOpResponse &b) {
  using ::std::swap;
  swap(a.result_set_metadata, b.result_set_metadata);
  swap(a.results, b.results);
}

const char* TExecRequest::ascii_fingerprint = "1C016EECD0A86E8488A03ED102679100";
const uint8_t TExecRequest::binary_fingerprint[16] = {0x1C,0x01,0x6E,0xEC,0xD0,0xA8,0x6E,0x84,0x88,0xA0,0x3E,0xD1,0x02,0x67,0x91,0x00};

uint32_t TExecRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stmt_type = false;
  bool isset_query_options = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast119;
          xfer += iprot->readI32(ecast119);
          this->stmt_type = ( ::impala::TStmtType::type)ecast119;
          isset_stmt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          isset_query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_exec_request.read(iprot);
          this->__isset.query_exec_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ddl_exec_request.read(iprot);
          this->__isset.ddl_exec_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          this->__isset.result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->explain_result.read(iprot);
          this->__isset.explain_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stmt_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_query_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExecRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExecRequest");

  ++fcnt;
  xfer += oprot->writeFieldBegin("stmt_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->stmt_type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->query_options.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_exec_request) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("query_exec_request", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->query_exec_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ddl_exec_request) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("ddl_exec_request", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ddl_exec_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set_metadata) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->result_set_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.explain_result) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("explain_result", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->explain_result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExecRequest &a, TExecRequest &b) {
  using ::std::swap;
  swap(a.stmt_type, b.stmt_type);
  swap(a.query_options, b.query_options);
  swap(a.query_exec_request, b.query_exec_request);
  swap(a.ddl_exec_request, b.ddl_exec_request);
  swap(a.result_set_metadata, b.result_set_metadata);
  swap(a.explain_result, b.explain_result);
  swap(a.__isset, b.__isset);
}

} // namespace
