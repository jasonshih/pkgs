/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ImpalaInternalService_TYPES_H
#define ImpalaInternalService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Status_types.h"
#include "Types_types.h"
#include "Exprs_types.h"
#include "Descriptors_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "DataSinks_types.h"
#include "Data_types.h"
#include "RuntimeProfile_types.h"
#include "ImpalaService_types.h"


namespace impala {

struct ImpalaInternalServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _ImpalaInternalServiceVersion_VALUES_TO_NAMES;

typedef struct _TQueryOptions__isset {
  _TQueryOptions__isset() : abort_on_error(true), max_errors(true), disable_codegen(true), batch_size(true), num_nodes(true), max_scan_range_length(true), num_scanner_threads(true), max_io_buffers(true), allow_unsupported_formats(true), default_order_by_limit(true), debug_action(true), mem_limit(true), abort_on_default_limit_exceeded(true) {}
  bool abort_on_error;
  bool max_errors;
  bool disable_codegen;
  bool batch_size;
  bool num_nodes;
  bool max_scan_range_length;
  bool num_scanner_threads;
  bool max_io_buffers;
  bool allow_unsupported_formats;
  bool default_order_by_limit;
  bool debug_action;
  bool mem_limit;
  bool abort_on_default_limit_exceeded;
} _TQueryOptions__isset;

class TQueryOptions {
 public:

  static const char* ascii_fingerprint; // = "7ED06B6A6ADFDB99E5CE3EDEF45B4ABC";
  static const uint8_t binary_fingerprint[16]; // = {0x7E,0xD0,0x6B,0x6A,0x6A,0xDF,0xDB,0x99,0xE5,0xCE,0x3E,0xDE,0xF4,0x5B,0x4A,0xBC};

  TQueryOptions() : abort_on_error(false), max_errors(0), disable_codegen(false), batch_size(0), num_nodes(0), max_scan_range_length(0LL), num_scanner_threads(0), max_io_buffers(0), allow_unsupported_formats(false), default_order_by_limit(-1LL), debug_action(""), mem_limit(0LL), abort_on_default_limit_exceeded(false) {
  }

  virtual ~TQueryOptions() throw() {}

  bool abort_on_error;
  int32_t max_errors;
  bool disable_codegen;
  int32_t batch_size;
  int32_t num_nodes;
  int64_t max_scan_range_length;
  int32_t num_scanner_threads;
  int32_t max_io_buffers;
  bool allow_unsupported_formats;
  int64_t default_order_by_limit;
  std::string debug_action;
  int64_t mem_limit;
  bool abort_on_default_limit_exceeded;

  _TQueryOptions__isset __isset;

  void __set_abort_on_error(const bool val) {
    abort_on_error = val;
    __isset.abort_on_error = true;
  }

  void __set_max_errors(const int32_t val) {
    max_errors = val;
    __isset.max_errors = true;
  }

  void __set_disable_codegen(const bool val) {
    disable_codegen = val;
    __isset.disable_codegen = true;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
    __isset.batch_size = true;
  }

  void __set_num_nodes(const int32_t val) {
    num_nodes = val;
    __isset.num_nodes = true;
  }

  void __set_max_scan_range_length(const int64_t val) {
    max_scan_range_length = val;
    __isset.max_scan_range_length = true;
  }

  void __set_num_scanner_threads(const int32_t val) {
    num_scanner_threads = val;
    __isset.num_scanner_threads = true;
  }

  void __set_max_io_buffers(const int32_t val) {
    max_io_buffers = val;
    __isset.max_io_buffers = true;
  }

  void __set_allow_unsupported_formats(const bool val) {
    allow_unsupported_formats = val;
    __isset.allow_unsupported_formats = true;
  }

  void __set_default_order_by_limit(const int64_t val) {
    default_order_by_limit = val;
    __isset.default_order_by_limit = true;
  }

  void __set_debug_action(const std::string& val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  void __set_mem_limit(const int64_t val) {
    mem_limit = val;
    __isset.mem_limit = true;
  }

  void __set_abort_on_default_limit_exceeded(const bool val) {
    abort_on_default_limit_exceeded = val;
    __isset.abort_on_default_limit_exceeded = true;
  }

  bool operator == (const TQueryOptions & rhs) const
  {
    if (__isset.abort_on_error != rhs.__isset.abort_on_error)
      return false;
    else if (__isset.abort_on_error && !(abort_on_error == rhs.abort_on_error))
      return false;
    if (__isset.max_errors != rhs.__isset.max_errors)
      return false;
    else if (__isset.max_errors && !(max_errors == rhs.max_errors))
      return false;
    if (__isset.disable_codegen != rhs.__isset.disable_codegen)
      return false;
    else if (__isset.disable_codegen && !(disable_codegen == rhs.disable_codegen))
      return false;
    if (__isset.batch_size != rhs.__isset.batch_size)
      return false;
    else if (__isset.batch_size && !(batch_size == rhs.batch_size))
      return false;
    if (__isset.num_nodes != rhs.__isset.num_nodes)
      return false;
    else if (__isset.num_nodes && !(num_nodes == rhs.num_nodes))
      return false;
    if (__isset.max_scan_range_length != rhs.__isset.max_scan_range_length)
      return false;
    else if (__isset.max_scan_range_length && !(max_scan_range_length == rhs.max_scan_range_length))
      return false;
    if (__isset.num_scanner_threads != rhs.__isset.num_scanner_threads)
      return false;
    else if (__isset.num_scanner_threads && !(num_scanner_threads == rhs.num_scanner_threads))
      return false;
    if (__isset.max_io_buffers != rhs.__isset.max_io_buffers)
      return false;
    else if (__isset.max_io_buffers && !(max_io_buffers == rhs.max_io_buffers))
      return false;
    if (__isset.allow_unsupported_formats != rhs.__isset.allow_unsupported_formats)
      return false;
    else if (__isset.allow_unsupported_formats && !(allow_unsupported_formats == rhs.allow_unsupported_formats))
      return false;
    if (__isset.default_order_by_limit != rhs.__isset.default_order_by_limit)
      return false;
    else if (__isset.default_order_by_limit && !(default_order_by_limit == rhs.default_order_by_limit))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.mem_limit != rhs.__isset.mem_limit)
      return false;
    else if (__isset.mem_limit && !(mem_limit == rhs.mem_limit))
      return false;
    if (__isset.abort_on_default_limit_exceeded != rhs.__isset.abort_on_default_limit_exceeded)
      return false;
    else if (__isset.abort_on_default_limit_exceeded && !(abort_on_default_limit_exceeded == rhs.abort_on_default_limit_exceeded))
      return false;
    return true;
  }
  bool operator != (const TQueryOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryOptions &a, TQueryOptions &b);

typedef struct _TScanRangeParams__isset {
  _TScanRangeParams__isset() : volume_id(true) {}
  bool volume_id;
} _TScanRangeParams__isset;

class TScanRangeParams {
 public:

  static const char* ascii_fingerprint; // = "49EB5061C355C63039A2B1360DCA31EE";
  static const uint8_t binary_fingerprint[16]; // = {0x49,0xEB,0x50,0x61,0xC3,0x55,0xC6,0x30,0x39,0xA2,0xB1,0x36,0x0D,0xCA,0x31,0xEE};

  TScanRangeParams() : volume_id(-1) {
  }

  virtual ~TScanRangeParams() throw() {}

   ::impala::TScanRange scan_range;
  int32_t volume_id;

  _TScanRangeParams__isset __isset;

  void __set_scan_range(const  ::impala::TScanRange& val) {
    scan_range = val;
  }

  void __set_volume_id(const int32_t val) {
    volume_id = val;
    __isset.volume_id = true;
  }

  bool operator == (const TScanRangeParams & rhs) const
  {
    if (!(scan_range == rhs.scan_range))
      return false;
    if (__isset.volume_id != rhs.__isset.volume_id)
      return false;
    else if (__isset.volume_id && !(volume_id == rhs.volume_id))
      return false;
    return true;
  }
  bool operator != (const TScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRangeParams &a, TScanRangeParams &b);


class TPlanFragmentDestination {
 public:

  static const char* ascii_fingerprint; // = "2051EF3AC86CAA635A348C806F3F3AE0";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x51,0xEF,0x3A,0xC8,0x6C,0xAA,0x63,0x5A,0x34,0x8C,0x80,0x6F,0x3F,0x3A,0xE0};

  TPlanFragmentDestination() {
  }

  virtual ~TPlanFragmentDestination() throw() {}

   ::impala::TUniqueId fragment_instance_id;
   ::impala::TNetworkAddress server;

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_server(const  ::impala::TNetworkAddress& val) {
    server = val;
  }

  bool operator == (const TPlanFragmentDestination & rhs) const
  {
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(server == rhs.server))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentDestination &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentDestination & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b);

typedef struct _TPlanFragmentExecParams__isset {
  _TPlanFragmentExecParams__isset() : destinations(false), debug_node_id(false), debug_phase(false), debug_action(false) {}
  bool destinations;
  bool debug_node_id;
  bool debug_phase;
  bool debug_action;
} _TPlanFragmentExecParams__isset;

class TPlanFragmentExecParams {
 public:

  static const char* ascii_fingerprint; // = "BB37ED8AA279F326A9A871018AAAB452";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0x37,0xED,0x8A,0xA2,0x79,0xF3,0x26,0xA9,0xA8,0x71,0x01,0x8A,0xAA,0xB4,0x52};

  TPlanFragmentExecParams() : debug_node_id(0), debug_phase(( ::impala::TExecNodePhase::type)0), debug_action(( ::impala::TDebugAction::type)0) {
  }

  virtual ~TPlanFragmentExecParams() throw() {}

   ::impala::TUniqueId query_id;
   ::impala::TUniqueId fragment_instance_id;
  std::map< ::impala::TPlanNodeId, std::vector<TScanRangeParams> >  per_node_scan_ranges;
  std::map< ::impala::TPlanNodeId, int32_t>  per_exch_num_senders;
  std::vector<TPlanFragmentDestination>  destinations;
   ::impala::TPlanNodeId debug_node_id;
   ::impala::TExecNodePhase::type debug_phase;
   ::impala::TDebugAction::type debug_action;

  _TPlanFragmentExecParams__isset __isset;

  void __set_query_id(const  ::impala::TUniqueId& val) {
    query_id = val;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_per_node_scan_ranges(const std::map< ::impala::TPlanNodeId, std::vector<TScanRangeParams> > & val) {
    per_node_scan_ranges = val;
  }

  void __set_per_exch_num_senders(const std::map< ::impala::TPlanNodeId, int32_t> & val) {
    per_exch_num_senders = val;
  }

  void __set_destinations(const std::vector<TPlanFragmentDestination> & val) {
    destinations = val;
    __isset.destinations = true;
  }

  void __set_debug_node_id(const  ::impala::TPlanNodeId val) {
    debug_node_id = val;
    __isset.debug_node_id = true;
  }

  void __set_debug_phase(const  ::impala::TExecNodePhase::type val) {
    debug_phase = val;
    __isset.debug_phase = true;
  }

  void __set_debug_action(const  ::impala::TDebugAction::type val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  bool operator == (const TPlanFragmentExecParams & rhs) const
  {
    if (!(query_id == rhs.query_id))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (!(per_exch_num_senders == rhs.per_exch_num_senders))
      return false;
    if (!(destinations == rhs.destinations))
      return false;
    if (__isset.debug_node_id != rhs.__isset.debug_node_id)
      return false;
    else if (__isset.debug_node_id && !(debug_node_id == rhs.debug_node_id))
      return false;
    if (__isset.debug_phase != rhs.__isset.debug_phase)
      return false;
    else if (__isset.debug_phase && !(debug_phase == rhs.debug_phase))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentExecParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentExecParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b);


class TQueryGlobals {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TQueryGlobals() : now_string() {
  }

  virtual ~TQueryGlobals() throw() {}

  std::string now_string;

  void __set_now_string(const std::string& val) {
    now_string = val;
  }

  bool operator == (const TQueryGlobals & rhs) const
  {
    if (!(now_string == rhs.now_string))
      return false;
    return true;
  }
  bool operator != (const TQueryGlobals &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryGlobals & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryGlobals &a, TQueryGlobals &b);

typedef struct _TExecPlanFragmentParams__isset {
  _TExecPlanFragmentParams__isset() : fragment(false), desc_tbl(false), params(false), coord(false), backend_num(false), query_globals(false), query_options(false) {}
  bool fragment;
  bool desc_tbl;
  bool params;
  bool coord;
  bool backend_num;
  bool query_globals;
  bool query_options;
} _TExecPlanFragmentParams__isset;

class TExecPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "52614A84C8B33D71799EAC0BA0BB5D3A";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0x61,0x4A,0x84,0xC8,0xB3,0x3D,0x71,0x79,0x9E,0xAC,0x0B,0xA0,0xBB,0x5D,0x3A};

  TExecPlanFragmentParams() : protocol_version((ImpalaInternalServiceVersion::type)0), backend_num(0) {
  }

  virtual ~TExecPlanFragmentParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TPlanFragment fragment;
   ::impala::TDescriptorTable desc_tbl;
  TPlanFragmentExecParams params;
   ::impala::TNetworkAddress coord;
  int32_t backend_num;
  TQueryGlobals query_globals;
  TQueryOptions query_options;

  _TExecPlanFragmentParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment(const  ::impala::TPlanFragment& val) {
    fragment = val;
    __isset.fragment = true;
  }

  void __set_desc_tbl(const  ::impala::TDescriptorTable& val) {
    desc_tbl = val;
    __isset.desc_tbl = true;
  }

  void __set_params(const TPlanFragmentExecParams& val) {
    params = val;
    __isset.params = true;
  }

  void __set_coord(const  ::impala::TNetworkAddress& val) {
    coord = val;
    __isset.coord = true;
  }

  void __set_backend_num(const int32_t val) {
    backend_num = val;
    __isset.backend_num = true;
  }

  void __set_query_globals(const TQueryGlobals& val) {
    query_globals = val;
    __isset.query_globals = true;
  }

  void __set_query_options(const TQueryOptions& val) {
    query_options = val;
    __isset.query_options = true;
  }

  bool operator == (const TExecPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment != rhs.__isset.fragment)
      return false;
    else if (__isset.fragment && !(fragment == rhs.fragment))
      return false;
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    if (__isset.coord != rhs.__isset.coord)
      return false;
    else if (__isset.coord && !(coord == rhs.coord))
      return false;
    if (__isset.backend_num != rhs.__isset.backend_num)
      return false;
    else if (__isset.backend_num && !(backend_num == rhs.backend_num))
      return false;
    if (__isset.query_globals != rhs.__isset.query_globals)
      return false;
    else if (__isset.query_globals && !(query_globals == rhs.query_globals))
      return false;
    if (__isset.query_options != rhs.__isset.query_options)
      return false;
    else if (__isset.query_options && !(query_options == rhs.query_options))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b);

typedef struct _TExecPlanFragmentResult__isset {
  _TExecPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TExecPlanFragmentResult__isset;

class TExecPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TExecPlanFragmentResult() {
  }

  virtual ~TExecPlanFragmentResult() throw() {}

   ::impala::TStatus status;

  _TExecPlanFragmentResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TExecPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b);

typedef struct _TInsertExecStatus__isset {
  _TInsertExecStatus__isset() : num_appended_rows(false) {}
  bool num_appended_rows;
} _TInsertExecStatus__isset;

class TInsertExecStatus {
 public:

  static const char* ascii_fingerprint; // = "14FC82A619CDEFD6F41C2666F80D0A4E";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0xFC,0x82,0xA6,0x19,0xCD,0xEF,0xD6,0xF4,0x1C,0x26,0x66,0xF8,0x0D,0x0A,0x4E};

  TInsertExecStatus() {
  }

  virtual ~TInsertExecStatus() throw() {}

  std::map<std::string, int64_t>  num_appended_rows;
  std::map<std::string, std::string>  files_to_move;

  _TInsertExecStatus__isset __isset;

  void __set_num_appended_rows(const std::map<std::string, int64_t> & val) {
    num_appended_rows = val;
    __isset.num_appended_rows = true;
  }

  void __set_files_to_move(const std::map<std::string, std::string> & val) {
    files_to_move = val;
  }

  bool operator == (const TInsertExecStatus & rhs) const
  {
    if (__isset.num_appended_rows != rhs.__isset.num_appended_rows)
      return false;
    else if (__isset.num_appended_rows && !(num_appended_rows == rhs.num_appended_rows))
      return false;
    if (!(files_to_move == rhs.files_to_move))
      return false;
    return true;
  }
  bool operator != (const TInsertExecStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInsertExecStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInsertExecStatus &a, TInsertExecStatus &b);

typedef struct _TReportExecStatusParams__isset {
  _TReportExecStatusParams__isset() : query_id(false), backend_num(false), fragment_instance_id(false), status(false), done(false), profile(false), insert_exec_status(false), error_log(false) {}
  bool query_id;
  bool backend_num;
  bool fragment_instance_id;
  bool status;
  bool done;
  bool profile;
  bool insert_exec_status;
  bool error_log;
} _TReportExecStatusParams__isset;

class TReportExecStatusParams {
 public:

  static const char* ascii_fingerprint; // = "7E33EACA01416132EEEA03AB2A543AD7";
  static const uint8_t binary_fingerprint[16]; // = {0x7E,0x33,0xEA,0xCA,0x01,0x41,0x61,0x32,0xEE,0xEA,0x03,0xAB,0x2A,0x54,0x3A,0xD7};

  TReportExecStatusParams() : protocol_version((ImpalaInternalServiceVersion::type)0), backend_num(0), done(0) {
  }

  virtual ~TReportExecStatusParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId query_id;
  int32_t backend_num;
   ::impala::TUniqueId fragment_instance_id;
   ::impala::TStatus status;
  bool done;
   ::impala::TRuntimeProfileTree profile;
  TInsertExecStatus insert_exec_status;
  std::vector<std::string>  error_log;

  _TReportExecStatusParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_query_id(const  ::impala::TUniqueId& val) {
    query_id = val;
    __isset.query_id = true;
  }

  void __set_backend_num(const int32_t val) {
    backend_num = val;
    __isset.backend_num = true;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
    __isset.fragment_instance_id = true;
  }

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  void __set_done(const bool val) {
    done = val;
    __isset.done = true;
  }

  void __set_profile(const  ::impala::TRuntimeProfileTree& val) {
    profile = val;
    __isset.profile = true;
  }

  void __set_insert_exec_status(const TInsertExecStatus& val) {
    insert_exec_status = val;
    __isset.insert_exec_status = true;
  }

  void __set_error_log(const std::vector<std::string> & val) {
    error_log = val;
    __isset.error_log = true;
  }

  bool operator == (const TReportExecStatusParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.query_id != rhs.__isset.query_id)
      return false;
    else if (__isset.query_id && !(query_id == rhs.query_id))
      return false;
    if (__isset.backend_num != rhs.__isset.backend_num)
      return false;
    else if (__isset.backend_num && !(backend_num == rhs.backend_num))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.done != rhs.__isset.done)
      return false;
    else if (__isset.done && !(done == rhs.done))
      return false;
    if (__isset.profile != rhs.__isset.profile)
      return false;
    else if (__isset.profile && !(profile == rhs.profile))
      return false;
    if (__isset.insert_exec_status != rhs.__isset.insert_exec_status)
      return false;
    else if (__isset.insert_exec_status && !(insert_exec_status == rhs.insert_exec_status))
      return false;
    if (__isset.error_log != rhs.__isset.error_log)
      return false;
    else if (__isset.error_log && !(error_log == rhs.error_log))
      return false;
    return true;
  }
  bool operator != (const TReportExecStatusParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReportExecStatusParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TReportExecStatusParams &a, TReportExecStatusParams &b);

typedef struct _TReportExecStatusResult__isset {
  _TReportExecStatusResult__isset() : status(false) {}
  bool status;
} _TReportExecStatusResult__isset;

class TReportExecStatusResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TReportExecStatusResult() {
  }

  virtual ~TReportExecStatusResult() throw() {}

   ::impala::TStatus status;

  _TReportExecStatusResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TReportExecStatusResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TReportExecStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReportExecStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TReportExecStatusResult &a, TReportExecStatusResult &b);

typedef struct _TCancelPlanFragmentParams__isset {
  _TCancelPlanFragmentParams__isset() : fragment_instance_id(false) {}
  bool fragment_instance_id;
} _TCancelPlanFragmentParams__isset;

class TCancelPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "7A58C455A7D49FCE68DC528A7710E205";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x58,0xC4,0x55,0xA7,0xD4,0x9F,0xCE,0x68,0xDC,0x52,0x8A,0x77,0x10,0xE2,0x05};

  TCancelPlanFragmentParams() : protocol_version((ImpalaInternalServiceVersion::type)0) {
  }

  virtual ~TCancelPlanFragmentParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId fragment_instance_id;

  _TCancelPlanFragmentParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
    __isset.fragment_instance_id = true;
  }

  bool operator == (const TCancelPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b);

typedef struct _TCancelPlanFragmentResult__isset {
  _TCancelPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TCancelPlanFragmentResult__isset;

class TCancelPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TCancelPlanFragmentResult() {
  }

  virtual ~TCancelPlanFragmentResult() throw() {}

   ::impala::TStatus status;

  _TCancelPlanFragmentResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TCancelPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b);

typedef struct _TTransmitDataParams__isset {
  _TTransmitDataParams__isset() : dest_fragment_instance_id(false), dest_node_id(false), row_batch(false), eos(false) {}
  bool dest_fragment_instance_id;
  bool dest_node_id;
  bool row_batch;
  bool eos;
} _TTransmitDataParams__isset;

class TTransmitDataParams {
 public:

  static const char* ascii_fingerprint; // = "ECE4CA3EAF435336ACF50B1B42112259";
  static const uint8_t binary_fingerprint[16]; // = {0xEC,0xE4,0xCA,0x3E,0xAF,0x43,0x53,0x36,0xAC,0xF5,0x0B,0x1B,0x42,0x11,0x22,0x59};

  TTransmitDataParams() : protocol_version((ImpalaInternalServiceVersion::type)0), dest_node_id(0), eos(0) {
  }

  virtual ~TTransmitDataParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId dest_fragment_instance_id;
   ::impala::TPlanNodeId dest_node_id;
   ::impala::TRowBatch row_batch;
  bool eos;

  _TTransmitDataParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_dest_fragment_instance_id(const  ::impala::TUniqueId& val) {
    dest_fragment_instance_id = val;
    __isset.dest_fragment_instance_id = true;
  }

  void __set_dest_node_id(const  ::impala::TPlanNodeId val) {
    dest_node_id = val;
    __isset.dest_node_id = true;
  }

  void __set_row_batch(const  ::impala::TRowBatch& val) {
    row_batch = val;
    __isset.row_batch = true;
  }

  void __set_eos(const bool val) {
    eos = val;
    __isset.eos = true;
  }

  bool operator == (const TTransmitDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    if (__isset.row_batch != rhs.__isset.row_batch)
      return false;
    else if (__isset.row_batch && !(row_batch == rhs.row_batch))
      return false;
    if (__isset.eos != rhs.__isset.eos)
      return false;
    else if (__isset.eos && !(eos == rhs.eos))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataParams &a, TTransmitDataParams &b);

typedef struct _TTransmitDataResult__isset {
  _TTransmitDataResult__isset() : status(false) {}
  bool status;
} _TTransmitDataResult__isset;

class TTransmitDataResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TTransmitDataResult() {
  }

  virtual ~TTransmitDataResult() throw() {}

   ::impala::TStatus status;

  _TTransmitDataResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TTransmitDataResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataResult &a, TTransmitDataResult &b);

} // namespace

#endif
