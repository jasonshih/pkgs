/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Exprs_types.h"

#include <algorithm>

namespace impala {

int _kTExprNodeTypeValues[] = {
  TExprNodeType::AGG_EXPR,
  TExprNodeType::ARITHMETIC_EXPR,
  TExprNodeType::BINARY_PRED,
  TExprNodeType::BOOL_LITERAL,
  TExprNodeType::CASE_EXPR,
  TExprNodeType::CAST_EXPR,
  TExprNodeType::COMPOUND_PRED,
  TExprNodeType::DATE_LITERAL,
  TExprNodeType::FLOAT_LITERAL,
  TExprNodeType::FUNCTION_CALL,
  TExprNodeType::INT_LITERAL,
  TExprNodeType::IN_PRED,
  TExprNodeType::IS_NULL_PRED,
  TExprNodeType::LIKE_PRED,
  TExprNodeType::LITERAL_PRED,
  TExprNodeType::NULL_LITERAL,
  TExprNodeType::SLOT_REF,
  TExprNodeType::STRING_LITERAL,
  TExprNodeType::TUPLE_IS_NULL_PRED
};
const char* _kTExprNodeTypeNames[] = {
  "AGG_EXPR",
  "ARITHMETIC_EXPR",
  "BINARY_PRED",
  "BOOL_LITERAL",
  "CASE_EXPR",
  "CAST_EXPR",
  "COMPOUND_PRED",
  "DATE_LITERAL",
  "FLOAT_LITERAL",
  "FUNCTION_CALL",
  "INT_LITERAL",
  "IN_PRED",
  "IS_NULL_PRED",
  "LIKE_PRED",
  "LITERAL_PRED",
  "NULL_LITERAL",
  "SLOT_REF",
  "STRING_LITERAL",
  "TUPLE_IS_NULL_PRED"
};
const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kTExprNodeTypeValues, _kTExprNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAggregationOpValues[] = {
  TAggregationOp::INVALID,
  TAggregationOp::COUNT,
  TAggregationOp::MAX,
  TAggregationOp::DISTINCT_PC,
  TAggregationOp::MERGE_PC,
  TAggregationOp::DISTINCT_PCSA,
  TAggregationOp::MERGE_PCSA,
  TAggregationOp::MIN,
  TAggregationOp::SUM
};
const char* _kTAggregationOpNames[] = {
  "INVALID",
  "COUNT",
  "MAX",
  "DISTINCT_PC",
  "MERGE_PC",
  "DISTINCT_PCSA",
  "MERGE_PCSA",
  "MIN",
  "SUM"
};
const std::map<int, const char*> _TAggregationOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTAggregationOpValues, _kTAggregationOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* TAggregateExpr::ascii_fingerprint = "0CAF0E42754E65C5573E4F81DB5F43FD";
const uint8_t TAggregateExpr::binary_fingerprint[16] = {0x0C,0xAF,0x0E,0x42,0x75,0x4E,0x65,0xC5,0x57,0x3E,0x4F,0x81,0xDB,0x5F,0x43,0xFD};

uint32_t TAggregateExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_star = false;
  bool isset_is_distinct = false;
  bool isset_op = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_star);
          isset_is_star = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_distinct);
          isset_is_distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->op = (TAggregationOp::type)ecast0;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_star)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_distinct)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAggregateExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TAggregateExpr");

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_star", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_star);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_distinct", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_distinct);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAggregateExpr &a, TAggregateExpr &b) {
  using ::std::swap;
  swap(a.is_star, b.is_star);
  swap(a.is_distinct, b.is_distinct);
  swap(a.op, b.op);
}

const char* TBoolLiteral::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TBoolLiteral::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TBoolLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TBoolLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TBoolLiteral");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TBoolLiteral &a, TBoolLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TCaseExpr::ascii_fingerprint = "403F0C4586060E367DA428DD09C59C9C";
const uint8_t TCaseExpr::binary_fingerprint[16] = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

uint32_t TCaseExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_has_case_expr = false;
  bool isset_has_else_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_case_expr);
          isset_has_case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_else_expr);
          isset_has_else_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_has_case_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_else_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCaseExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TCaseExpr");

  ++fcnt;
  xfer += oprot->writeFieldBegin("has_case_expr", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->has_case_expr);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("has_else_expr", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->has_else_expr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCaseExpr &a, TCaseExpr &b) {
  using ::std::swap;
  swap(a.has_case_expr, b.has_case_expr);
  swap(a.has_else_expr, b.has_else_expr);
}

const char* TDateLiteral::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t TDateLiteral::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t TDateLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDateLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TDateLiteral");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDateLiteral &a, TDateLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TFloatLiteral::ascii_fingerprint = "66FFB53A2471384C03D9F21F6FACA58F";
const uint8_t TFloatLiteral::binary_fingerprint[16] = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

uint32_t TFloatLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFloatLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TFloatLiteral");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFloatLiteral &a, TFloatLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TIntLiteral::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t TIntLiteral::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t TIntLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIntLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TIntLiteral");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIntLiteral &a, TIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TInPredicate::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TInPredicate::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TInPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_in = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_in);
          isset_is_not_in = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_in)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TInPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TInPredicate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_not_in", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_in);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInPredicate &a, TInPredicate &b) {
  using ::std::swap;
  swap(a.is_not_in, b.is_not_in);
}

const char* TIsNullPredicate::ascii_fingerprint = "5892306F7B861249AE8E27C8ED619593";
const uint8_t TIsNullPredicate::binary_fingerprint[16] = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

uint32_t TIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_not_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_null);
          isset_is_not_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_not_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TIsNullPredicate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_not_null", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_not_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIsNullPredicate &a, TIsNullPredicate &b) {
  using ::std::swap;
  swap(a.is_not_null, b.is_not_null);
}

const char* TLikePredicate::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TLikePredicate::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TLikePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_escape_char = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape_char);
          isset_escape_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_escape_char)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLikePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TLikePredicate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("escape_char", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->escape_char);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLikePredicate &a, TLikePredicate &b) {
  using ::std::swap;
  swap(a.escape_char, b.escape_char);
}

const char* TLiteralPredicate::ascii_fingerprint = "403F0C4586060E367DA428DD09C59C9C";
const uint8_t TLiteralPredicate::binary_fingerprint[16] = {0x40,0x3F,0x0C,0x45,0x86,0x06,0x0E,0x36,0x7D,0xA4,0x28,0xDD,0x09,0xC5,0x9C,0x9C};

uint32_t TLiteralPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_is_null = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          isset_is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_null)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLiteralPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TLiteralPredicate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLiteralPredicate &a, TLiteralPredicate &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.is_null, b.is_null);
}

const char* TTupleIsNullPredicate::ascii_fingerprint = "A803C54EAD95E24D90C5E66FB98EA72B";
const uint8_t TTupleIsNullPredicate::binary_fingerprint[16] = {0xA8,0x03,0xC5,0x4E,0xAD,0x95,0xE2,0x4D,0x90,0xC5,0xE6,0x6F,0xB9,0x8E,0xA7,0x2B};

uint32_t TTupleIsNullPredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tuple_ids.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->tuple_ids.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += iprot->readI32(this->tuple_ids[_i5]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tuple_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTupleIsNullPredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TTupleIsNullPredicate");

  ++fcnt;
  xfer += oprot->writeFieldBegin("tuple_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->tuple_ids.size()));
    std::vector< ::impala::TTupleId> ::const_iterator _iter6;
    for (_iter6 = this->tuple_ids.begin(); _iter6 != this->tuple_ids.end(); ++_iter6)
    {
      xfer += oprot->writeI32((*_iter6));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b) {
  using ::std::swap;
  swap(a.tuple_ids, b.tuple_ids);
}

const char* TSlotRef::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TSlotRef::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TSlotRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_slot_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slot_id);
          isset_slot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_slot_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSlotRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TSlotRef");

  ++fcnt;
  xfer += oprot->writeFieldBegin("slot_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->slot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSlotRef &a, TSlotRef &b) {
  using ::std::swap;
  swap(a.slot_id, b.slot_id);
}

const char* TStringLiteral::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t TStringLiteral::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t TStringLiteral::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TStringLiteral::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TStringLiteral");

  ++fcnt;
  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringLiteral &a, TStringLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

const char* TExprNode::ascii_fingerprint = "A9F2B8D465AC204F0A7F0CA0C087C86A";
const uint8_t TExprNode::binary_fingerprint[16] = {0xA9,0xF2,0xB8,0xD4,0x65,0xAC,0x20,0x4F,0x0A,0x7F,0x0C,0xA0,0xC0,0x87,0xC8,0x6A};

uint32_t TExprNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_type = false;
  bool isset_type = false;
  bool isset_num_children = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->node_type = (TExprNodeType::type)ecast7;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->type = ( ::impala::TPrimitiveType::type)ecast8;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->opcode = ( ::impala::TExprOpcode::type)ecast9;
          this->__isset.opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_expr.read(iprot);
          this->__isset.agg_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bool_literal.read(iprot);
          this->__isset.bool_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->case_expr.read(iprot);
          this->__isset.case_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->date_literal.read(iprot);
          this->__isset.date_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->float_literal.read(iprot);
          this->__isset.float_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->int_literal.read(iprot);
          this->__isset.int_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->in_predicate.read(iprot);
          this->__isset.in_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->is_null_pred.read(iprot);
          this->__isset.is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->like_pred.read(iprot);
          this->__isset.like_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->literal_pred.read(iprot);
          this->__isset.literal_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slot_ref.read(iprot);
          this->__isset.slot_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->string_literal.read(iprot);
          this->__isset.string_literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tuple_is_null_pred.read(iprot);
          this->__isset.tuple_is_null_pred = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExprNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExprNode");

  ++fcnt;
  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  ++fcnt;
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.opcode) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("opcode", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->opcode);
    xfer += oprot->writeFieldEnd();
  }
  ++fcnt;
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agg_expr) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("agg_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->agg_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bool_literal) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("bool_literal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->bool_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.case_expr) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("case_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->case_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.date_literal) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("date_literal", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->date_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.float_literal) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("float_literal", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->float_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.int_literal) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("int_literal", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->int_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_predicate) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("in_predicate", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->in_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_null_pred) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("is_null_pred", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.like_pred) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("like_pred", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->like_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.literal_pred) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("literal_pred", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->literal_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slot_ref) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("slot_ref", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->slot_ref.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_literal) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("string_literal", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->string_literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tuple_is_null_pred) {
    ++fcnt;
    xfer += oprot->writeFieldBegin("tuple_is_null_pred", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->tuple_is_null_pred.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExprNode &a, TExprNode &b) {
  using ::std::swap;
  swap(a.node_type, b.node_type);
  swap(a.type, b.type);
  swap(a.opcode, b.opcode);
  swap(a.num_children, b.num_children);
  swap(a.agg_expr, b.agg_expr);
  swap(a.bool_literal, b.bool_literal);
  swap(a.case_expr, b.case_expr);
  swap(a.date_literal, b.date_literal);
  swap(a.float_literal, b.float_literal);
  swap(a.int_literal, b.int_literal);
  swap(a.in_predicate, b.in_predicate);
  swap(a.is_null_pred, b.is_null_pred);
  swap(a.like_pred, b.like_pred);
  swap(a.literal_pred, b.literal_pred);
  swap(a.slot_ref, b.slot_ref);
  swap(a.string_literal, b.string_literal);
  swap(a.tuple_is_null_pred, b.tuple_is_null_pred);
  swap(a.__isset, b.__isset);
}

const char* TExpr::ascii_fingerprint = "9D47FA18B80D57FB20B9D57BFF9B95CF";
const uint8_t TExpr::binary_fingerprint[16] = {0x9D,0x47,0xFA,0x18,0xB8,0x0D,0x57,0xFB,0x20,0xB9,0xD5,0x7B,0xFF,0x9B,0x95,0xCF};

uint32_t TExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->nodes.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->nodes[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  uint32_t fcnt = 0;
  xfer += oprot->writeStructBegin("TExpr");

  ++fcnt;
  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TExprNode> ::const_iterator _iter15;
    for (_iter15 = this->nodes.begin(); _iter15 != this->nodes.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TExpr &a, TExpr &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

} // namespace
